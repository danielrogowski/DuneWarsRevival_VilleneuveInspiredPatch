#############################################################################
# File: Arrakis.py version 0.66
# Author: Rich Marinaccio
# Copyright 2009 Rich Marinaccio
#
# Changelog
# Version 0.53 - deliverator - Exposed various parameters as In-Game Options
# Version 0.54 - davidlallen - thin 2x2 peak blocks 
# Version 0.55 - deliverator - reworked options and tuned a few things
# Version 0.56 - koma13      - do not override sdk start locations
# Version 0.57 - davidlallen - remove tundra
# Version 0.58 - davidlallen - new start plot selection from scratch
# Version 0.59 - davidlallen - minor modifications to plot selection
# Version 0.60 - deliverator - tweaked mesa % and added new Large Islands landmass style
# Version 0.61 - davidlallen - reject start locations too close or far from pole
# Version 0.62 - deliverator - add further post-processing to add Mesa to flat areas
# Version 0.63 - deliverator - Custom addFeatures for Dune Wars
# Version 0.64 - deliverator - Added Cave features, no adjacent Peaks, remove Goody Huts from starting plots, removed small islands
# Version 0.65 - M - Added more land percentage options and corrected a minor bug related to Mammoth size (faster initialization now)
# Version 0.66 - M - Added Random options

from CvPythonExtensions import *
import CvUtil
import CvMapGeneratorUtil 

from array import array
from random import random,randint,seed
import math
import sys
import time
import os
import operator

class MapConstants :
    def __init__(self):
        return
    def initialize(self):
        print "Initializing map constants"
#############################################################################
# GLOBAL TUNING VARIABLES: Change these to customize the map results
        
        #Percent of land vs. water
        self.landPercent = 0.24
               
        #How many map squares will be above peak threshold and thus 'peaks'.
        self.PeakPercent = 0.06

        #How many map squares will be above hill threshold and thus 'hills' unless
        #they are also above peak threshold in which case they will be 'peaks'.
        self.HillPercent = 0.0
        self.SnowPercent = 0.15
        self.GrassPercent = 0.40
        self.PlainsPercent = 0.93

        #In addition to the relative peak and hill generation, there is also a
        #process that changes flats to hills or peaks based on altitude. This tends
        #to randomize the high altitude areas somewhat and improve their appearance.
        #These variables control the frequency of hills and peaks at the highest altitude.
        self.HillChanceAtOne = 0.0
        self.PeakChanceAtOne = 0.30

        #This variable adjusts the amount of bonuses on the map. Values above 1.0 will add bonus
        #bonuses. People often want lots of bonuses, and for those people, this variable is definately
        #a bonus.
        self.BonusBonus = 1.0
               
        #Height and Width of main climate and height maps. This does not
        #reflect the resulting map size. Both dimensions( + 1 if wrapping in
        #that dimension = False) must be evenly divisble by self.hmMaxGrain
        self.hmWidth = 193
        self.hmHeight = 193

        #Controls wrapping (not sure if this makes sense yet)
        self.WrapX = False
        self.WrapY = False
        
        #Size of largest map increment to begin midpoint displacement. Must
        #be a power of 2.
        self.hmMaxGrain = 16
        
        #Size of largest map increment to begin midpoint displacement for terrain field.
        #Must be a power of 2.
        self.hmMaxTFGrain = 8

        #These are not mountain peaks, but points on the height map initialized
        #to 1.0 before the midpoint displacement process begins. This sets the
        #percentage of 'peaks' for points that are not on the grain margin.
        self.hmInitialPeakPercent = 0.30
        
        #Scales the heuristic for random midpoint displacement. A higher number
        #will create more noise(bumpy), a smaller number will make less
        #noise(smooth).
        self.hmNoiseLevel = 1.0

        #Filter size for altitude smoothing and distance finding. Must be
        #odd number
        self.distanceFilterSize = 11

        #Altitudes are attenuated at this distance from pole
        self.innerAttenuationRadius = 45.0
        self.outerAttenuationRadius = 55.0

        #Min and max distances of shield wall from pole
        self.maxShieldWallRadius = 65.0
        self.minShieldWallRadius = 45.0

        #Radius of polar ice as a percent of map width. 
        self.polarIceRadiusPercent = 0.10
        
        #scale of the dune texture. Must be 1.0 or less.
        self.duneScale = 0.5

        #Altitudes for hills and land on the dune texture
        self.duneHillAlt = 0.75
        self.duneLandAlt = 0.50

        #Dunes at max height at this distance from continent
        self.duneMaxHeightDistance = 7.0

        #Minimum deep desert 'lake' size. anything smaller will be filled in.
        self.minInlandSeaSize = 10
        
        #---These values are for evaluating starting locations

        #The following values are used for assigning starting locations. For now,
        #they have the same ratio that is found in CvPlot::getFoundValue
        self.CommerceValue = 20
        self.ProductionValue = 40
        self.FoodValue = 30
        
        #Decides whether to use the Python random generator or the one that is
        #intended for use with civ maps. The Python random has much higher precision
        #than the civ one. 53 bits for Python result versus 16 for getMapRand. The
        #rand they use is actually 32 bits, but they shorten the result to 16 bits.
        #However, the problem with using the Python random is that it may create
        #syncing issues for multi-player now or in the future, therefore it must
        #be optional.
        self.UsePythonRandom = True        
        
        #Below here are static defines. If you change these, the map won't work.
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        self.L = 0
        self.N = 1
        self.S = 2
        self.E = 3
        self.W = 4
        self.NE = 5
        self.NW = 6
        self.SE = 7
        self.SW = 8

        self.NO_SEPARATION = 0
        self.NORTH_SOUTH_SEPARATION = 1
        self.EAST_WEST_SEPARATION = 2

        self.width = 104
        self.height = 104

        self.OCEAN = 0
        self.LAND = 1
        self.HILLS = 2
        self.PEAK = 3

        self.OCEAN = 0
        self.COAST = 1
        self.MARSH = 2
        self.GRASS = 3
        self.PLAINS = 4
        self.DESERT = 5
        self.SNOW = 7
        self.POLAR = 8
        self.POLAR_COAST = 9
        self.SALT = 10
        self.POLAR_PLAINS = 11

        self.minimumLandInChoke = 0.5
        self.duneWidth = 168
        self.duneHeight = 111
        self.dunedata = [107,117,127,134,146,157,167,173,173,167,156,138, \
        121,103,91,85,87,93,103,117,131,142,152,157, \
        159,157,154,148,140,131,121,109,99,89,82,76, \
        76,78,83,91,97,101,103,101,97,91,85,83, \
        83,85,91,99,105,109,111,111,107,101,95,87, \
        82,78,74,74,76,85,99,119,142,161,173,173, \
        161,140,117,93,82,82,93,115,142,173,197,218, \
        228,226,210,186,154,121,91,72,66,72,87,109, \
        131,150,159,161,150,131,105,82,66,60,66,78, \
        91,105,115,123,127,133,134,136,134,131,127,123, \
        119,117,113,109,103,95,89,83,80,80,83,93, \
        105,121,138,156,169,177,177,165,146,123,97,78, \
        72,76,93,117,144,165,177,175,159,133,101,72, \
        45,30,19,14,14,16,23,33,48,64,80,95, \
        125,134,144,148,154,156,157,156,150,138,125,111, \
        99,91,89,93,103,115,125,134,140,142,144,142, \
        140,136,133,131,127,121,117,109,101,91,83,76, \
        72,70,70,74,78,82,85,85,87,87,87,89, \
        93,97,103,107,109,105,101,93,87,82,78,76, \
        78,80,85,93,103,117,133,148,161,167,165,152, \
        133,109,89,78,80,95,121,150,181,205,224,231, \
        228,212,186,150,115,83,62,54,60,76,97,117, \
        134,146,148,138,123,99,76,58,52,56,72,91, \
        111,127,136,140,142,140,138,133,125,115,107,99, \
        95,93,93,93,93,93,91,93,95,101,111,121, \
        131,142,150,156,159,157,150,134,117,97,82,76, \
        80,95,121,144,165,177,173,156,129,93,58,30, \
        10,0,0,5,12,19,27,39,56,74,93,111, \
        140,146,148,146,142,138,133,129,123,113,105,99, \
        97,97,105,115,125,133,136,136,133,129,123,119, \
        119,119,121,125,127,125,123,115,105,91,80,68, \
        58,54,54,58,64,72,80,87,91,95,99,101, \
        103,105,105,103,99,93,85,80,76,76,78,83, \
        91,99,111,121,133,144,154,159,161,156,142,123, \
        101,83,74,78,95,123,154,186,210,228,234,229, \
        212,184,146,107,74,50,37,43,58,78,97,111, \
        121,125,119,109,91,74,62,54,60,74,95,115, \
        133,142,144,144,140,133,125,115,105,95,87,85, \
        85,89,95,101,105,109,113,117,121,125,131,136, \
        140,142,142,138,133,125,117,107,95,85,83,89, \
        103,123,146,163,171,167,150,121,83,48,14,0, \
        0,0,0,5,19,30,43,58,76,95,113,129, \
        144,140,134,125,117,109,105,103,103,103,103,107, \
        111,119,127,134,140,140,134,125,115,107,101,103, \
        107,117,127,134,138,136,131,117,101,83,66,52, \
        43,41,43,52,64,78,89,97,103,107,107,105, \
        103,99,93,89,83,78,76,74,78,83,93,103, \
        113,123,133,142,150,154,156,154,146,133,113,93, \
        78,72,76,93,123,156,186,212,229,234,229,212, \
        183,144,101,62,33,21,21,35,54,72,85,95, \
        97,95,89,82,74,68,66,74,85,105,123,136, \
        142,142,136,129,121,111,103,95,87,83,83,87, \
        93,103,113,123,131,134,136,136,136,134,134,133, \
        131,125,117,109,99,93,89,87,87,91,97,111, \
        127,146,159,165,159,142,113,78,39,3,0,0, \
        0,0,0,19,37,52,70,85,103,119,133,140, \
        131,121,109,97,89,87,89,95,103,111,119,127, \
        134,140,144,144,140,131,119,107,95,91,93,101, \
        115,131,144,152,152,146,131,109,87,66,50,37, \
        35,37,48,60,76,89,101,107,111,109,103,97, \
        89,82,74,70,68,70,74,82,89,101,111,121, \
        129,136,142,146,146,146,142,134,123,107,91,78, \
        72,78,95,121,152,183,209,226,231,226,209,181, \
        142,99,56,23,3,0,12,30,48,62,70,76, \
        76,74,74,74,76,82,91,105,121,136,144,146, \
        138,127,115,103,95,89,85,85,87,91,97,107, \
        117,129,138,146,150,152,148,142,134,127,121,115, \
        107,99,91,83,78,78,80,87,95,105,117,131, \
        142,152,154,148,133,107,74,37,3,0,0,0, \
        0,0,21,43,64,82,97,111,125,133,138,138, \
        107,95,83,76,76,82,91,105,119,133,142,148, \
        152,152,146,138,127,113,99,91,87,91,103,119, \
        136,154,163,167,159,142,119,93,68,50,37,33, \
        37,45,58,72,87,99,105,109,105,99,89,80, \
        70,62,58,58,64,72,82,93,103,113,121,127, \
        131,133,133,133,131,127,123,115,105,93,85,82, \
        85,99,123,148,177,197,212,218,214,201,175,140, \
        99,58,21,0,0,0,12,31,45,56,62,66, \
        66,70,76,83,95,109,127,140,152,156,152,138, \
        121,101,87,80,78,80,85,93,103,113,125,134, \
        142,150,154,156,154,150,140,129,117,107,97,91, \
        87,82,78,74,74,78,85,97,107,119,129,134, \
        138,140,133,121,101,74,43,14,0,0,0,0, \
        7,31,54,76,93,107,119,127,131,131,127,119, \
        80,74,70,72,82,95,113,131,144,154,159,159, \
        154,146,134,121,107,95,89,89,95,109,127,146, \
        163,175,177,169,152,125,95,70,48,37,33,37, \
        45,56,68,80,89,95,99,95,89,80,72,62, \
        54,50,52,56,66,78,89,99,107,111,115,117, \
        117,117,115,113,111,109,107,105,101,97,97,99, \
        111,127,146,167,184,195,199,195,184,163,136,103, \
        66,31,5,0,0,10,27,43,56,62,66,70, \
        74,80,91,105,123,140,156,165,167,159,142,119, \
        95,78,68,70,80,91,105,119,133,142,148,152, \
        154,152,148,144,136,129,117,107,95,87,83,82, \
        82,83,83,85,87,93,101,109,117,123,125,125, \
        121,115,107,93,76,56,35,19,7,5,12,30, \
        48,68,87,103,115,121,123,121,115,107,99,89, \
        66,68,76,87,105,123,140,156,163,165,161,152, \
        140,127,113,101,93,91,95,105,121,138,157,173, \
        181,183,173,154,127,95,66,45,33,31,37,45, \
        54,62,70,78,82,85,83,80,74,66,60,54, \
        50,52,54,62,72,82,89,93,97,97,99,99, \
        99,99,99,101,101,105,107,109,111,113,117,123, \
        133,146,157,167,173,175,169,159,146,127,101,76, \
        50,30,16,16,27,41,56,68,74,78,82,83, \
        87,97,109,125,142,157,167,169,161,144,121,95, \
        76,66,68,82,99,119,136,150,157,159,157,152, \
        142,133,123,115,107,99,91,85,83,83,85,91, \
        97,103,107,109,109,111,111,113,111,111,107,103, \
        99,95,87,82,72,62,52,45,43,48,58,72, \
        87,101,111,117,119,113,107,97,87,78,72,66, \
        72,83,99,117,134,150,161,167,167,159,148,133, \
        117,105,97,93,95,103,117,134,152,167,179,184, \
        181,171,150,123,91,62,37,25,23,31,41,50, \
        56,60,64,68,70,72,72,70,68,62,60,56, \
        56,56,60,64,70,76,78,80,80,80,82,83, \
        87,91,97,101,107,111,117,121,123,127,133,138, \
        144,148,152,152,148,142,134,123,111,97,83,68, \
        56,50,50,56,66,80,87,93,95,95,95,95, \
        97,105,115,129,144,154,157,152,138,117,93,76, \
        66,70,85,107,131,152,165,171,169,159,146,131, \
        113,99,87,82,78,78,80,83,89,99,109,119, \
        127,131,133,131,123,117,109,101,95,91,87,85, \
        87,87,89,89,87,85,85,83,85,89,95,105, \
        113,117,119,113,103,91,80,68,60,54,56,62, \
        95,113,129,144,156,163,165,161,154,140,125,109, \
        97,93,93,101,113,129,146,163,177,184,184,177, \
        161,140,115,85,58,33,19,14,21,33,43,50, \
        54,54,56,60,64,68,70,72,72,70,66,64, \
        62,60,58,60,60,62,64,64,64,66,72,78, \
        85,95,103,113,119,123,127,129,131,133,134,136, \
        138,136,133,127,119,111,105,99,93,87,83,82, \
        80,82,87,95,105,111,115,113,109,105,101,97, \
        99,101,109,119,129,133,131,121,105,85,72,66, \
        72,87,113,138,159,173,177,171,159,140,117,95, \
        78,66,60,60,66,76,87,99,113,127,138,148, \
        152,152,146,134,121,107,93,82,76,76,78,83, \
        91,101,107,113,117,119,119,117,115,115,115,117, \
        119,115,107,95,82,66,56,48,48,52,62,76, \
        125,140,152,157,157,156,148,138,127,115,103,95, \
        93,97,109,125,142,159,173,183,184,181,167,150, \
        127,103,80,56,37,23,16,19,30,37,45,50, \
        52,52,56,60,66,72,78,80,80,78,72,66, \
        60,54,50,48,48,50,50,54,56,62,70,78, \
        89,101,113,121,127,129,129,129,127,127,127,127, \
        123,119,111,103,97,93,91,91,91,93,97,101, \
        107,113,119,123,127,127,123,117,109,101,95,91, \
        89,91,95,101,105,107,101,89,78,68,64,72, \
        89,113,138,159,171,175,169,154,133,107,82,62, \
        50,45,52,64,80,95,113,131,146,157,163,165, \
        163,154,138,121,103,85,72,66,68,74,85,99, \
        113,127,136,142,144,142,138,133,125,119,115,111, \
        109,101,91,76,64,52,48,48,58,70,87,107, \
        148,154,156,150,140,129,119,109,101,95,95,97, \
        107,121,136,154,169,181,184,183,173,156,134,111, \
        89,70,56,45,37,35,35,39,45,50,54,54, \
        54,58,62,70,76,83,85,87,85,80,72,62, \
        52,45,39,39,39,43,45,52,56,60,68,78, \
        87,101,111,119,123,123,121,119,117,117,115,115, \
        111,105,99,93,91,91,93,97,103,107,113,119, \
        123,129,131,131,129,123,115,107,99,91,87,83, \
        83,83,87,89,89,87,82,74,68,66,74,91, \
        113,134,154,163,163,156,140,121,99,76,58,45, \
        45,54,70,89,111,131,148,159,169,173,171,165, \
        152,136,117,97,80,66,62,64,76,91,109,127, \
        142,154,157,159,156,148,136,125,115,105,101,97, \
        93,89,80,70,60,56,60,70,83,101,119,134, \
        150,146,136,123,109,97,87,85,87,93,103,117, \
        133,148,163,175,183,183,175,161,142,121,97,76, \
        60,54,54,56,62,66,70,70,70,68,66,62, \
        62,66,72,80,85,89,91,89,83,76,66,56, \
        48,41,39,39,41,45,50,54,56,58,62,70, \
        80,91,101,109,113,113,109,109,109,109,111,111, \
        107,103,99,97,97,99,105,109,111,115,117,119, \
        121,123,121,119,115,109,101,95,91,87,85,83, \
        83,85,87,87,87,85,82,80,80,85,97,115, \
        133,146,152,148,138,123,105,87,72,60,54,56, \
        66,83,105,127,148,161,173,177,175,169,157,144, \
        127,109,89,76,64,62,68,82,99,121,140,156, \
        163,165,163,156,144,131,119,105,95,89,87,89, \
        89,87,82,76,72,74,83,97,113,129,140,148, \
        131,119,103,87,76,70,72,80,91,107,125,140, \
        156,167,175,179,175,165,148,129,105,83,66,56, \
        54,60,74,87,99,107,107,101,93,85,78,72, \
        70,72,78,83,87,91,89,87,82,74,64,56, \
        50,48,48,50,52,54,54,54,52,50,52,58, \
        68,78,89,97,101,101,101,103,105,111,113,115, \
        113,109,107,105,105,107,109,111,109,109,107,105, \
        105,105,103,101,99,95,93,93,93,93,93,95, \
        95,95,95,97,99,101,103,105,109,117,125,134, \
        140,140,133,121,105,89,78,70,66,68,76,87, \
        105,125,144,161,173,179,179,171,161,148,131,115, \
        99,85,76,70,70,78,89,109,129,148,161,167, \
        167,159,148,133,117,105,93,85,82,83,87,91, \
        95,95,93,89,89,93,103,117,129,136,140,138, \
        93,78,66,58,58,64,76,93,113,131,148,159, \
        167,169,167,159,148,131,111,91,74,62,56,58, \
        70,87,107,125,136,140,134,123,109,93,82,74, \
        72,74,78,83,87,89,89,87,83,78,72,66, \
        64,62,62,62,60,58,54,50,45,43,45,52, \
        62,74,83,91,95,97,99,103,107,113,119,119, \
        117,115,111,109,107,107,107,103,99,93,89,87, \
        85,87,89,91,95,97,101,105,107,109,109,107, \
        105,103,103,107,115,123,133,140,144,148,146,142, \
        134,121,105,89,76,68,68,72,82,95,111,129, \
        146,161,173,179,181,175,163,148,133,117,103,91, \
        85,80,80,83,91,105,119,136,150,161,165,161, \
        150,134,117,101,87,80,78,78,82,89,97,103, \
        107,105,103,99,97,101,109,119,125,125,119,107, \
        52,41,39,45,58,76,97,119,138,152,157,159, \
        156,148,138,125,109,93,78,66,60,62,70,83, \
        101,123,142,156,159,156,144,127,107,89,76,70, \
        70,74,80,87,91,95,95,95,91,87,83,80, \
        76,74,72,68,64,58,52,48,45,45,50,58, \
        68,78,85,91,95,97,99,103,107,113,115,117, \
        115,111,107,103,103,101,97,93,87,82,78,78, \
        80,85,91,99,107,115,121,125,127,125,121,115, \
        107,103,105,113,129,146,163,171,173,167,154,134, \
        113,93,76,66,64,68,80,97,115,134,152,165, \
        175,179,179,175,163,150,134,119,105,93,87,87, \
        89,95,103,113,123,133,142,148,152,152,146,134, \
        119,101,87,76,72,72,76,83,93,103,111,115, \
        113,109,101,97,95,97,103,105,103,95,82,66, \
        19,21,33,54,78,103,127,144,154,156,152,140, \
        129,113,99,85,76,66,62,62,70,82,99,119, \
        136,152,163,167,161,148,131,111,91,78,68,66, \
        70,80,87,97,105,107,109,107,103,99,93,89, \
        83,78,72,66,60,54,50,50,54,58,66,74, \
        82,87,91,93,93,93,93,95,99,103,107,107, \
        105,103,99,97,97,95,93,91,85,83,83,85, \
        91,99,109,121,129,136,140,140,138,131,119,107, \
        99,95,101,119,142,165,184,191,186,171,144,115, \
        87,68,58,60,72,89,111,133,154,171,181,186, \
        183,177,163,150,134,119,105,95,89,89,93,101, \
        111,123,133,140,144,146,146,142,134,125,111,97, \
        85,76,70,68,72,78,87,97,105,113,115,113, \
        107,99,91,85,83,85,89,87,80,64,45,30, \
        5,21,45,78,109,133,150,157,154,144,127,107, \
        89,76,66,62,60,62,70,82,97,115,134,148, \
        159,165,163,156,142,123,105,87,76,68,68,74, \
        82,93,105,115,121,121,119,115,107,101,95,87, \
        82,76,68,62,56,54,56,62,70,78,83,89, \
        91,93,91,89,85,83,83,85,89,93,97,99, \
        99,99,97,99,101,103,103,103,101,101,103,107, \
        115,123,133,140,148,150,150,144,133,121,107,93, \
        87,89,101,125,152,177,191,193,183,157,125,91, \
        66,54,58,72,95,121,146,167,183,189,189,183, \
        169,152,134,117,103,93,89,89,93,103,115,127, \
        138,148,154,154,150,142,131,117,103,89,78,68, \
        64,66,70,78,85,93,101,105,109,111,107,101, \
        93,85,80,78,78,82,80,74,60,39,19,5, \
        10,37,72,107,134,152,157,152,136,115,93,74, \
        60,54,54,60,70,82,95,111,129,144,157,163, \
        163,156,144,127,109,91,78,70,68,72,80,89, \
        103,115,125,131,131,129,121,111,103,95,87,82, \
        76,72,66,62,62,64,68,76,83,91,95,95, \
        93,87,82,78,74,74,76,82,87,93,99,103, \
        105,107,109,113,117,121,125,125,125,123,125,129, \
        133,138,146,150,150,148,142,131,117,103,91,82, \
        82,91,109,134,159,179,187,181,161,133,99,70, \
        56,58,74,99,127,152,173,186,191,189,179,161, \
        140,119,101,89,85,85,93,103,117,129,142,152, \
        157,157,154,146,134,121,105,89,76,64,58,58, \
        64,74,85,95,101,105,105,103,101,97,93,87, \
        82,78,78,80,83,85,82,70,52,27,5,0, \
        27,60,97,129,148,154,146,129,107,83,64,52, \
        50,56,68,82,99,115,129,142,152,159,159,156, \
        144,129,111,93,78,68,64,68,78,89,101,113, \
        123,131,134,134,131,123,111,101,91,85,82,80, \
        78,76,74,72,72,76,80,85,89,91,91,87, \
        82,76,72,70,70,74,80,89,99,107,115,119, \
        123,125,129,133,136,142,144,142,140,138,136,136, \
        136,140,142,142,138,133,123,111,99,89,83,82, \
        89,103,123,142,161,171,169,156,133,103,78,62, \
        60,74,99,127,152,171,183,184,181,171,154,131, \
        109,91,80,80,85,99,115,131,144,154,159,161, \
        157,148,138,125,111,97,83,72,64,60,62,68, \
        80,93,105,111,111,105,97,89,85,82,82,82, \
        82,83,87,93,97,97,89,72,45,21,5,7, \
        45,80,111,133,142,136,121,101,80,62,52,54, \
        62,80,99,119,134,148,154,157,156,152,142,129, \
        113,95,80,68,62,64,72,83,97,111,121,127, \
        131,131,131,125,117,109,99,89,85,83,83,85, \
        87,87,87,85,83,83,83,83,82,82,78,76, \
        72,70,72,74,80,89,99,111,123,133,138,140, \
        142,142,144,146,148,150,150,148,142,136,131,127, \
        127,127,127,123,119,111,103,95,89,87,87,93, \
        103,119,133,146,152,150,140,123,101,82,68,66, \
        78,99,123,148,163,171,171,165,156,142,123,103, \
        87,78,78,87,105,125,144,156,165,165,159,150, \
        136,123,109,97,89,82,78,76,76,78,83,93, \
        105,113,117,115,105,93,82,74,72,76,82,89, \
        95,103,109,111,111,105,89,68,43,21,12,21, \
        60,87,111,121,121,109,93,78,66,60,64,76, \
        95,117,136,152,163,165,161,152,140,127,111,97, \
        83,72,66,64,70,80,95,109,121,129,129,127, \
        123,117,113,107,103,97,93,89,91,93,97,99, \
        101,101,97,93,87,82,76,72,68,68,68,70, \
        74,80,87,95,107,117,129,138,146,154,156,156, \
        152,148,146,144,144,144,140,136,129,121,115,111, \
        109,109,109,107,103,97,93,89,91,93,99,109, \
        119,129,134,136,133,125,109,93,80,72,72,82, \
        99,119,138,152,156,154,146,136,127,115,103,91, \
        85,85,95,113,133,152,165,171,167,157,142,123, \
        105,91,83,82,83,87,93,99,105,109,115,119, \
        121,121,115,103,87,74,66,66,74,85,97,109, \
        119,123,123,121,113,101,82,58,35,21,19,35, \
        66,85,95,99,93,85,78,72,72,80,93,111, \
        133,150,163,171,169,159,146,127,109,93,82,74, \
        70,70,74,83,95,111,125,133,134,131,121,107, \
        99,93,91,93,95,99,101,103,107,109,111,111, \
        109,103,95,87,80,72,66,62,62,64,72,82, \
        93,107,119,129,138,146,152,156,159,159,157,152, \
        146,138,133,129,127,125,123,117,111,103,99,97, \
        99,101,103,101,97,93,91,93,97,103,109,115, \
        121,125,125,119,109,97,85,78,74,78,85,99, \
        117,131,138,140,136,127,119,111,107,103,101,99, \
        101,109,123,138,156,167,171,165,154,133,111,91, \
        76,70,74,83,95,111,123,133,136,136,134,131, \
        123,111,97,82,68,60,60,70,85,103,119,131, \
        134,133,125,115,101,83,64,45,31,23,30,45, \
        64,72,76,76,74,74,78,87,99,115,131,146, \
        159,167,169,163,152,134,115,95,80,70,68,72, \
        80,91,103,119,133,142,148,144,133,115,97,82, \
        74,74,82,93,105,115,123,125,125,123,117,109, \
        101,89,80,72,66,62,62,64,70,80,93,111, \
        127,142,154,159,161,159,157,154,150,146,142,136, \
        127,119,113,109,107,107,107,105,101,99,97,99, \
        103,105,107,105,101,95,93,95,97,103,107,111, \
        113,111,107,99,89,80,76,76,82,91,101,113, \
        123,127,125,119,111,103,99,99,103,109,117,121, \
        127,136,146,156,163,165,159,146,127,105,83,68, \
        62,68,82,101,121,140,152,157,156,148,136,123, \
        107,89,74,60,54,54,66,83,103,123,134,138, \
        136,125,111,95,80,64,50,39,31,33,39,52, \
        58,60,60,64,72,82,97,115,133,148,159,167, \
        167,163,152,136,117,97,80,68,62,64,76,91, \
        109,127,142,156,161,161,154,138,117,91,72,60, \
        62,72,89,111,129,140,144,142,134,121,107,93, \
        80,70,62,58,60,66,74,85,99,113,131,148, \
        161,173,175,173,165,156,144,134,127,123,119,115, \
        111,105,103,101,103,105,107,109,107,107,109,111, \
        115,115,113,109,101,93,89,89,89,93,95,97, \
        97,97,91,87,82,78,80,85,93,103,111,117, \
        117,113,105,97,91,91,95,105,117,129,138,144, \
        148,152,156,157,156,148,136,121,101,83,70,64, \
        68,82,103,125,146,161,167,163,154,138,119,99, \
        82,66,54,48,50,60,76,95,113,127,133,131, \
        121,107,91,76,64,56,50,45,45,45,50,54, \
        52,52,58,68,85,105,127,148,161,171,171,165, \
        154,138,119,99,80,66,58,58,66,83,103,127, \
        148,165,177,181,177,163,144,119,91,70,56,56, \
        68,89,115,138,154,161,157,144,127,105,85,70, \
        60,54,54,60,72,85,103,121,138,154,167,179, \
        184,186,179,167,150,133,117,107,101,101,103,105, \
        107,109,111,113,117,121,125,125,125,123,123,123, \
        123,121,115,105,95,85,80,78,80,82,85,89, \
        91,91,91,89,87,87,89,95,101,107,109,107, \
        103,95,89,87,89,97,109,123,136,148,154,156, \
        154,150,146,142,134,127,115,103,89,80,76,78, \
        87,103,125,144,157,163,161,152,134,113,93,76, \
        62,52,48,50,56,68,82,95,109,115,115,109, \
        97,85,76,68,64,64,64,64,64,62,58,54, \
        52,58,70,89,113,134,156,169,175,173,161,144, \
        123,101,82,66,56,54,58,72,91,117,142,165, \
        184,193,193,186,169,146,119,93,72,58,58,70, \
        93,119,144,163,171,167,152,129,103,80,62,52, \
        50,56,68,82,101,121,142,159,175,184,189,191, \
        187,179,161,142,123,105,93,87,89,95,107,117, \
        125,133,136,140,144,146,146,144,138,133,129,125, \
        119,113,105,95,85,76,72,72,74,80,87,93, \
        99,101,103,101,101,99,99,99,101,101,99,95, \
        91,89,87,93,101,115,129,140,150,154,152,148, \
        140,133,127,121,115,109,105,99,95,93,95,99, \
        109,123,134,146,150,148,138,125,105,85,70,60, \
        54,52,54,58,64,70,78,83,89,91,89,83, \
        80,74,74,76,82,85,87,85,82,72,62,56, \
        66,76,95,117,140,157,169,171,165,152,133,111, \
        87,70,56,52,54,64,82,105,131,156,179,195, \
        203,201,191,171,146,119,91,72,62,66,80,101, \
        127,152,169,177,173,156,131,103,78,58,50,52, \
        64,80,99,121,142,159,177,186,193,195,191,183, \
        169,152,131,111,95,85,82,87,99,113,129,144, \
        156,163,169,171,169,165,159,150,138,129,117,111, \
        105,99,95,87,82,78,78,80,87,95,105,113, \
        119,119,119,115,109,103,99,95,91,89,89,89, \
        91,93,101,109,121,131,140,146,146,142,134,125, \
        117,109,105,103,105,107,109,111,111,113,115,119, \
        123,127,131,133,129,123,111,97,82,70,60,58, \
        58,62,66,66,66,64,64,64,66,68,70,72, \
        74,80,87,97,105,111,109,103,93,80,68,62, \
        89,105,125,142,156,163,161,152,138,119,97,78, \
        62,54,54,62,76,95,119,142,165,186,199,205, \
        201,187,169,142,115,89,72,66,72,87,111,138, \
        159,175,179,173,156,131,101,76,58,50,56,72, \
        95,119,142,163,179,187,193,193,189,183,171,156, \
        136,119,101,87,82,83,93,109,127,146,163,177, \
        186,189,189,186,179,169,154,138,123,107,97,91, \
        89,89,91,93,95,95,99,107,115,125,133,136, \
        136,133,127,117,107,99,91,85,83,85,89,95, \
        103,111,119,129,134,138,138,134,127,117,107,99, \
        93,93,95,101,109,115,121,125,127,127,125,123, \
        121,119,115,111,107,99,91,82,74,68,64,66, \
        68,72,72,68,62,56,52,50,54,58,66,74, \
        83,93,105,117,125,127,123,113,101,87,80,80, \
        117,133,146,154,156,148,136,119,99,82,68,60, \
        58,62,74,93,113,134,154,173,186,195,197,191, \
        181,159,136,111,87,74,70,78,95,121,146,169, \
        181,181,171,150,125,97,74,58,54,64,83,109, \
        138,163,183,195,199,197,189,179,167,152,136,119, \
        105,91,83,83,89,105,125,144,165,183,193,201, \
        203,201,193,183,167,152,133,115,97,85,78,78, \
        85,95,107,117,125,131,138,144,150,156,156,152, \
        144,133,119,107,97,89,85,83,87,93,101,111, \
        121,131,134,136,134,129,121,111,99,91,85,83, \
        87,93,103,113,121,127,131,131,129,125,121,115, \
        109,103,99,97,95,91,89,83,80,76,72,72, \
        74,72,70,64,56,50,48,52,58,68,78,89, \
        99,109,117,125,129,129,123,115,107,101,99,105, \
        142,148,152,146,134,119,99,82,68,60,58,64, \
        76,91,111,133,150,165,177,184,186,184,177,163, \
        146,125,105,87,78,76,85,105,129,154,175,184, \
        184,171,146,119,91,70,58,58,72,93,123,152, \
        179,199,209,210,201,186,167,148,129,115,101,91, \
        85,83,89,99,117,138,161,181,195,205,210,207, \
        201,189,175,157,140,123,107,91,80,74,76,85, \
        99,119,136,152,163,171,175,177,177,173,165,152, \
        134,117,99,89,83,83,85,93,101,111,121,131, \
        136,138,136,131,121,109,97,87,82,78,80,87, \
        97,109,119,129,133,133,129,123,115,111,105,101, \
        99,97,97,97,99,101,101,97,91,85,78,72, \
        70,66,62,58,54,56,60,70,80,89,97,103, \
        109,113,117,119,121,121,119,119,117,119,125,133, \
        150,146,136,123,103,83,68,56,54,58,70,87, \
        109,131,150,165,175,179,177,173,163,154,142,127, \
        113,97,87,83,85,97,117,138,161,179,186,184, \
        169,146,117,89,68,60,64,80,103,133,163,189, \
        209,218,216,203,183,157,131,109,93,85,83,83, \
        89,99,115,133,154,175,193,205,210,210,203,191, \
        177,161,144,127,113,99,89,83,82,83,95,111, \
        133,154,173,187,197,201,199,195,186,173,154,133, \
        111,93,80,76,80,87,99,109,119,129,134,138, \
        138,134,125,113,99,89,82,78,78,83,93,105, \
        117,129,134,136,133,123,111,103,95,93,93,97, \
        101,105,109,115,119,121,119,113,101,87,76,66, \
        60,58,58,62,66,74,85,95,105,109,111,109, \
        105,103,101,103,105,111,117,125,131,138,144,148, \
        140,125,109,89,72,58,52,54,64,80,101,123, \
        144,163,175,179,177,169,157,142,129,117,107,99, \
        93,89,91,97,111,129,150,167,181,184,181,165, \
        142,115,87,70,62,70,87,113,144,173,195,212, \
        220,216,203,181,152,121,95,78,72,76,85,99, \
        117,133,152,169,186,201,209,210,205,193,179,161, \
        144,127,113,103,95,93,95,97,105,117,131,150, \
        169,187,203,212,214,210,203,189,173,154,131,109, \
        89,76,72,76,85,101,115,125,131,134,134,133, \
        127,117,107,95,87,82,82,85,95,105,117,129, \
        136,140,138,131,117,103,89,82,82,85,95,107, \
        117,125,133,136,138,136,129,117,99,82,68,58, \
        56,60,68,78,87,99,111,119,121,117,109,99, \
        89,85,83,87,97,109,123,134,144,150,152,148, \
        111,91,74,60,52,52,60,74,93,115,136,156, \
        171,179,179,173,159,144,125,109,97,89,87,89, \
        95,103,113,127,142,159,171,179,181,173,157,134, \
        111,87,72,68,78,97,123,154,181,201,214,218, \
        212,197,175,146,115,87,72,66,74,89,111,133, \
        154,171,186,197,207,209,207,195,181,163,144,127, \
        111,101,97,97,103,111,121,133,144,157,173,186, \
        199,210,216,216,210,197,183,163,144,125,105,89, \
        80,76,80,89,103,115,125,129,129,125,119,113, \
        107,99,93,91,89,95,101,111,123,131,138,142, \
        140,134,125,111,97,83,76,74,82,95,113,129, \
        140,148,150,150,144,136,125,109,91,74,64,60, \
        66,76,87,101,111,121,125,125,117,105,91,80, \
        72,70,76,85,99,117,133,144,150,150,142,129, \
        78,60,48,45,54,68,87,109,131,148,163,173, \
        177,173,163,148,131,111,95,83,80,83,91,105, \
        119,133,146,157,167,175,175,171,159,144,123,101, \
        83,74,74,85,107,134,161,186,203,212,212,205, \
        187,165,140,111,87,72,68,76,95,121,146,169, \
        187,199,207,209,205,197,184,167,148,129,111,99, \
        93,95,101,115,129,144,159,173,184,193,201,209, \
        212,212,209,199,184,165,148,129,113,99,89,85, \
        85,91,101,111,119,123,123,119,111,105,99,95, \
        93,93,97,103,111,121,133,140,146,148,146,138, \
        127,115,101,89,80,76,78,85,101,119,136,150, \
        157,159,154,146,136,123,111,95,82,72,70,76, \
        87,99,111,121,125,125,121,111,97,83,70,62, \
        62,68,80,95,113,129,140,144,142,131,115,97, \
        50,39,41,54,74,99,125,146,161,171,173,171, \
        161,150,134,117,101,89,82,82,87,101,117,134, \
        152,165,173,177,177,171,159,144,127,107,91,78, \
        72,78,91,115,142,169,189,203,209,205,193,175, \
        154,131,107,89,78,76,85,103,129,156,179,195, \
        207,209,207,197,186,169,152,133,115,101,93,93, \
        99,111,129,146,165,183,195,203,210,212,210,207, \
        201,191,181,163,146,127,109,97,89,89,93,99, \
        109,117,125,127,125,119,107,97,89,85,85,89, \
        95,105,115,129,140,152,157,159,157,148,134,119, \
        103,91,82,78,80,85,97,113,131,146,159,163, \
        161,152,140,129,115,105,95,87,83,83,89,101, \
        113,123,127,127,121,111,99,85,72,62,56,58, \
        66,82,97,113,127,134,136,133,121,103,83,66, \
        41,45,58,82,109,136,159,173,177,173,163,150, \
        134,119,105,93,87,85,89,99,115,134,152,169, \
        181,186,186,177,165,148,129,111,93,80,72,72, \
        80,97,123,148,173,191,201,201,193,179,159,138, \
        119,101,91,85,87,99,117,140,163,184,197,205, \
        205,197,184,169,152,134,119,105,97,95,99,109, \
        125,144,165,183,199,210,216,218,214,207,197,186, \
        173,157,142,125,107,93,85,83,87,99,113,127, \
        136,142,140,133,119,101,87,76,74,78,87,99, \
        115,129,142,156,165,171,169,161,148,131,111,93, \
        82,76,76,83,95,109,127,142,156,163,165,159, \
        148,133,117,105,97,93,93,95,101,109,119,127, \
        133,133,127,115,101,85,72,62,54,54,60,70, \
        85,101,115,125,131,129,123,111,95,78,62,48, \
        60,72,93,119,144,165,179,181,173,157,138,119, \
        105,95,89,89,95,103,117,134,152,167,183,191, \
        195,189,179,159,136,115,95,82,74,72,76,87, \
        107,129,152,175,187,195,191,179,161,138,119,101, \
        91,89,91,101,117,134,154,171,186,193,195,191, \
        181,167,150,133,117,105,99,97,101,111,125,142, \
        161,181,197,210,218,220,216,209,197,183,165,150, \
        134,119,105,93,83,80,82,89,103,121,138,150, \
        156,152,140,123,101,82,70,68,74,87,105,123, \
        140,154,163,171,173,171,161,144,127,105,87,76, \
        72,78,89,105,123,140,152,161,165,163,156,140, \
        123,105,93,89,91,99,109,119,131,138,142,144, \
        138,127,109,91,74,60,52,50,54,64,78,93, \
        107,119,125,125,121,113,101,89,78,66,60,56, \
        95,111,131,152,169,179,179,169,150,129,109,93, \
        87,87,95,107,121,136,154,169,181,189,195,193, \
        186,173,154,129,105,85,74,72,76,85,101,119, \
        140,159,175,184,186,179,163,142,119,99,83,80, \
        83,95,113,133,152,169,183,187,189,184,173,159, \
        144,129,115,103,95,95,99,111,125,142,159,179, \
        193,207,214,218,216,209,195,181,163,146,129,115, \
        103,95,87,83,83,89,99,113,131,146,159,163, \
        157,144,125,101,82,70,68,76,91,111,131,146, \
        157,165,169,167,161,152,136,119,101,85,78,76, \
        83,99,117,134,150,159,163,163,156,146,131,113, \
        97,87,85,91,105,121,136,150,157,159,156,144, \
        127,107,85,68,56,50,52,60,74,87,103,115, \
        121,123,119,111,103,93,85,80,78,78,80,85, \
        134,146,157,167,173,171,159,140,119,99,85,83, \
        89,103,119,136,154,169,183,189,193,191,186,177, \
        161,142,121,99,82,72,72,82,99,117,136,154, \
        169,179,181,177,163,146,125,101,82,68,66,76, \
        93,117,144,165,183,191,191,186,173,156,138,121, \
        105,95,91,89,95,105,121,140,157,177,191,203, \
        210,214,212,205,193,179,161,142,125,111,101,95, \
        91,93,95,99,105,117,129,142,154,163,163,157, \
        142,123,99,82,72,70,80,97,119,136,150,157, \
        159,157,154,146,136,123,109,95,85,82,85,97, \
        113,131,148,159,165,163,157,146,133,117,101,89, \
        83,83,93,111,131,150,165,173,175,167,152,131, \
        107,83,66,56,54,60,72,85,101,115,123,127, \
        123,115,103,93,85,82,83,89,97,105,115,125, \
        157,161,161,159,154,142,125,105,89,80,80,91, \
        109,131,152,169,183,189,191,189,183,171,157,144, \
        127,111,93,82,76,80,91,111,134,154,171,181, \
        183,179,167,152,131,107,85,70,60,60,70,91, \
        119,146,173,189,197,195,184,165,142,119,99,85, \
        82,82,89,101,115,134,154,173,189,201,209,210, \
        207,199,187,173,156,138,121,107,97,91,93,97, \
        105,113,123,131,138,148,156,161,163,159,150,134, \
        115,93,78,72,74,85,105,127,142,152,154,150, \
        142,133,125,117,109,101,93,89,91,99,111,129, \
        146,161,171,171,163,150,133,117,103,91,83,82, \
        87,99,119,138,157,173,181,179,171,154,131,107, \
        83,68,62,64,72,85,101,115,127,131,129,121, \
        109,95,85,80,82,87,99,113,127,140,148,156, \
        157,150,140,129,115,101,87,76,72,76,91,115, \
        140,161,179,189,193,189,183,169,154,138,123,109, \
        99,89,85,85,91,105,125,148,167,183,187,186, \
        177,161,140,119,95,76,64,58,60,72,91,119, \
        146,171,189,197,193,179,156,131,103,83,72,70, \
        78,91,109,129,150,169,184,199,207,210,207,197, \
        184,167,148,131,113,99,91,87,89,97,107,121, \
        134,148,157,163,167,169,167,161,152,138,121,103, \
        85,74,70,76,91,113,134,150,156,152,142,127, \
        113,101,95,93,93,95,99,103,115,129,144,161, \
        173,179,175,163,144,123,105,91,83,82,85,95, \
        111,129,146,163,175,179,175,163,148,127,103,83, \
        70,66,72,83,99,115,127,134,136,131,119,105, \
        89,80,76,82,91,109,127,144,157,165,167,163, \
        133,115,99,85,72,62,58,60,70,89,117,144, \
        167,184,191,189,183,169,152,134,119,105,95,89, \
        89,93,99,109,125,142,161,177,187,191,186,173, \
        156,133,109,89,74,66,64,70,83,101,123,146, \
        167,183,187,184,171,148,121,93,74,62,64,76, \
        95,121,144,165,183,195,203,207,205,197,183,165, \
        146,127,107,93,83,78,82,89,103,121,138,156, \
        169,179,183,183,179,169,157,142,125,107,89,78, \
        70,72,80,97,119,140,156,159,154,136,115,95, \
        83,78,82,89,101,111,123,133,146,159,171,179, \
        183,175,161,140,115,95,82,78,83,93,109,127, \
        142,157,169,173,171,161,148,131,111,93,78,70, \
        70,78,91,109,123,133,136,134,127,115,99,85, \
        76,74,80,95,115,134,152,165,171,169,161,148, \
        91,72,56,45,39,41,50,66,87,115,142,167, \
        183,187,183,171,154,134,117,101,91,85,85,93, \
        103,117,131,146,161,175,186,191,189,181,165,146, \
        123,103,85,76,72,76,85,101,117,134,150,163, \
        171,173,169,156,136,111,87,68,60,64,80,103, \
        131,156,179,193,203,205,201,193,183,167,148,127, \
        107,91,80,74,74,82,95,113,134,156,173,186, \
        191,193,189,181,167,150,133,113,95,80,70,68, \
        74,87,105,127,148,159,163,154,136,111,87,72, \
        68,74,89,107,127,142,156,165,173,177,181,179, \
        169,154,133,109,87,76,76,85,103,125,144,161, \
        173,179,177,165,150,131,109,91,78,70,66,70, \
        80,95,111,125,133,133,129,119,105,91,80,70, \
        70,78,95,115,134,152,163,167,163,152,134,113, \
        54,37,30,27,31,43,64,87,115,140,163,177, \
        181,173,157,138,119,101,89,82,82,89,101,117, \
        134,152,167,181,189,193,193,186,173,154,133,113, \
        95,83,80,83,93,107,121,136,148,157,161,161, \
        157,150,138,123,105,85,70,64,70,85,111,138, \
        165,187,201,205,203,193,181,165,148,131,113,97, \
        83,76,76,80,91,107,127,148,169,184,195,199, \
        195,187,173,157,140,121,105,89,76,70,72,80, \
        95,115,136,154,165,165,156,136,111,87,70,64, \
        72,89,115,138,159,175,183,184,183,177,169,157, \
        142,123,103,83,74,74,85,109,136,159,179,189, \
        191,183,167,142,115,91,72,62,58,60,70,82, \
        95,111,121,127,125,117,107,95,83,74,68,70, \
        76,91,109,127,142,152,154,148,134,115,93,72, \
        31,27,30,37,52,70,93,117,140,157,167,169, \
        159,144,123,103,89,80,80,85,97,113,133,152, \
        171,186,195,201,199,193,181,161,140,119,99,87, \
        82,83,93,109,127,142,156,163,165,161,154,142, \
        131,119,107,97,85,80,78,83,99,121,148,173, \
        191,203,205,197,184,167,146,129,113,101,91,85, \
        83,87,95,109,125,144,161,179,191,199,197,191, \
        179,161,142,125,109,95,85,80,78,82,91,107, \
        127,144,159,167,165,156,134,111,87,72,68,76, \
        95,123,148,171,186,193,191,184,171,156,140,125, \
        109,95,82,76,78,89,113,142,169,189,201,201, \
        189,169,140,109,80,60,48,48,58,70,83,97, \
        107,115,117,113,103,93,83,78,72,70,72,78, \
        87,101,115,125,131,131,125,113,97,78,60,43, \
        41,45,56,70,87,105,125,140,152,156,154,144, \
        129,111,93,82,78,82,93,111,131,152,169,186, \
        197,203,205,199,187,171,150,129,105,89,80,80, \
        87,103,123,142,159,173,177,173,163,148,131,115, \
        103,95,91,89,91,95,105,119,136,157,179,191, \
        199,197,187,171,152,131,113,99,93,91,93,99, \
        107,119,134,150,165,179,187,195,195,189,179,161, \
        142,123,107,95,87,87,89,93,99,111,123,138, \
        152,161,165,161,148,131,109,89,76,74,83,103, \
        129,154,177,191,197,193,183,163,142,121,105,93, \
        85,82,82,87,101,121,148,173,193,205,205,193, \
        171,142,109,78,56,43,45,58,74,89,101,107, \
        109,105,99,91,83,78,74,74,76,78,82,87, \
        93,99,105,107,105,99,89,78,66,54,45,39, \
        74,85,97,111,125,136,144,146,144,136,125,111, \
        95,83,78,80,89,105,127,148,169,186,199,205, \
        205,201,189,175,157,136,115,95,82,76,80,93, \
        113,134,156,173,183,184,179,163,142,123,103,91, \
        85,87,95,105,117,129,142,157,171,184,191,193, \
        187,175,157,136,117,101,91,89,93,105,117,131, \
        146,159,173,184,191,195,195,187,177,161,140,119, \
        101,87,80,80,87,97,109,121,133,142,150,157, \
        159,157,150,138,121,103,85,78,78,89,109,134, \
        157,177,187,191,186,173,152,129,105,87,78,76, \
        80,89,103,119,136,157,179,193,203,201,189,167, \
        140,109,80,60,50,52,64,82,97,109,111,105, \
        97,87,80,74,72,76,82,87,91,93,93,91, \
        91,89,87,83,80,72,66,60,56,54,58,64, \
        117,129,136,144,146,146,140,131,119,105,91,80, \
        74,76,85,99,119,142,165,184,199,209,209,203, \
        191,175,156,136,115,97,83,76,76,83,99,121, \
        144,165,181,187,187,177,159,138,115,95,83,82, \
        89,103,121,138,154,167,179,186,191,191,186,175, \
        159,140,121,103,91,85,89,99,115,134,152,169, \
        183,191,199,201,199,191,181,163,142,117,95,78, \
        66,64,72,85,105,123,138,152,157,161,161,157, \
        148,138,123,107,91,82,78,82,95,117,138,159, \
        173,181,179,171,156,136,115,93,76,68,70,80, \
        97,117,138,156,173,186,195,199,193,181,157,133, \
        105,80,66,60,64,78,95,111,119,117,107,93, \
        80,70,66,70,78,89,101,107,109,103,95,87, \
        80,74,72,70,68,64,64,66,72,80,91,103, \
        152,157,157,154,146,134,119,103,85,72,64,64, \
        72,87,109,134,157,179,195,207,212,209,199,181, \
        159,134,111,91,78,70,70,76,89,107,131,152, \
        171,183,187,183,171,152,131,107,89,82,82,93, \
        113,134,156,175,187,197,199,197,189,177,161,144, \
        125,107,93,85,85,93,105,125,146,167,184,197, \
        205,205,203,195,183,167,148,125,99,76,58,50, \
        50,62,82,107,131,150,163,167,167,159,150,138, \
        123,107,93,82,76,78,85,101,123,144,159,169, \
        171,163,150,134,117,99,83,72,66,70,83,105, \
        131,154,175,187,197,201,195,184,167,144,119,95, \
        78,68,68,78,93,113,127,133,129,113,95,78, \
        66,62,70,82,99,113,123,123,115,101,87,74, \
        68,66,70,74,78,82,87,95,107,119,133,144, \
        167,161,152,138,123,105,87,72,62,56,60,72, \
        91,119,146,171,191,205,212,212,203,189,169,144, \
        117,91,72,60,58,64,76,95,117,138,157,173, \
        181,181,173,159,138,117,99,83,80,83,99,121, \
        146,171,189,203,209,209,199,186,169,148,129,109, \
        95,85,83,89,99,115,134,154,173,187,199,205, \
        205,197,184,169,150,131,111,89,68,52,43,45, \
        58,80,107,134,154,167,169,163,152,138,123,107, \
        93,83,76,76,80,91,109,131,150,163,167,163, \
        150,133,113,95,82,74,70,70,80,93,117,142, \
        167,186,199,205,203,193,177,156,131,105,85,72, \
        68,74,89,109,131,144,148,140,123,99,78,64, \
        60,70,85,105,123,134,134,125,107,87,72,62, \
        64,74,87,101,111,121,129,136,144,154,161,165, \
        156,142,127,109,91,76,64,58,56,64,78,99, \
        127,156,181,199,210,212,207,195,177,154,129,103, \
        78,60,50,50,60,78,101,125,146,163,173,175, \
        171,159,142,121,101,85,78,78,85,105,129,154, \
        179,197,210,214,209,197,181,157,136,113,97,85, \
        82,85,95,111,129,146,161,173,184,189,193,189, \
        183,169,152,133,113,97,83,70,60,54,56,66, \
        85,111,136,156,165,163,154,138,119,103,89,80, \
        76,76,80,87,101,119,138,156,167,167,159,142, \
        119,97,80,68,64,68,78,89,109,131,154,175, \
        191,203,207,201,187,169,144,119,95,76,66,68, \
        80,99,123,146,161,165,156,134,105,78,60,56, \
        66,85,109,129,140,142,133,113,89,68,58,60, \
        74,95,119,138,152,161,165,167,169,169,167,163, \
        125,109,93,80,68,62,60,66,78,93,115,140, \
        167,187,205,212,210,199,183,163,138,115,91,72, \
        56,50,54,66,85,109,133,152,165,171,167,157, \
        140,121,99,82,72,68,74,87,109,134,161,184, \
        201,209,210,203,189,171,146,123,103,87,82,82, \
        91,105,125,142,157,169,173,175,173,169,165,157, \
        146,131,115,99,87,82,78,76,76,82,89,105, \
        123,142,156,161,157,142,123,99,82,70,66,70, \
        78,89,101,117,131,146,159,167,167,157,138,115, \
        91,72,62,60,68,83,101,121,142,163,181,193, \
        199,199,189,177,156,133,109,87,72,66,70,85, \
        107,134,157,175,179,169,146,113,80,54,45,54, \
        76,101,125,140,142,134,115,89,68,54,54,70, \
        95,127,156,177,186,189,186,179,169,159,150,138, \
        89,78,70,66,64,70,82,97,117,138,159,181, \
        197,209,212,205,191,171,148,123,101,83,70,62, \
        60,68,82,99,121,142,157,167,167,159,142,121, \
        99,78,64,56,58,70,89,113,140,165,184,197, \
        203,201,189,175,156,134,113,95,83,80,85,99, \
        119,138,157,171,177,177,167,156,144,134,125,117, \
        109,99,91,85,83,87,95,103,113,123,133,142, \
        152,159,159,150,133,109,83,64,54,52,62,78, \
        97,115,133,144,154,161,163,161,152,136,115,91, \
        74,64,64,72,89,107,129,148,165,179,186,187, \
        184,173,157,138,117,99,82,72,70,78,93,119, \
        144,167,184,189,181,156,121,82,50,31,33,52, \
        78,105,125,134,129,113,89,70,54,52,66,91, \
        125,157,183,197,201,195,183,165,148,131,115,101, \
        66,66,68,76,85,101,121,140,161,181,195,209, \
        212,210,201,183,157,133,109,91,80,72,72,76, \
        87,103,121,138,154,163,167,161,150,131,105,82, \
        60,45,41,50,66,89,117,144,167,183,191,193, \
        186,173,156,136,119,101,87,82,83,95,111,133, \
        154,171,184,186,181,165,146,125,107,95,91,87, \
        87,87,89,93,103,115,131,142,154,161,165,167, \
        165,157,144,123,99,76,56,43,45,56,76,101, \
        125,142,156,159,159,156,150,138,127,111,95,82, \
        74,74,82,95,111,129,146,159,169,173,171,163, \
        150,133,115,97,85,78,76,80,91,109,133,156, \
        177,191,195,186,161,127,85,48,19,10,21,43, \
        72,95,109,111,103,87,70,58,56,68,89,119, \
        150,177,193,199,191,177,156,133,111,93,80,72, \
        68,78,91,107,125,144,163,183,197,209,214,214, \
        207,193,173,146,121,97,82,76,78,85,97,111, \
        129,144,157,167,169,167,156,140,119,95,72,50, \
        37,35,45,66,93,121,146,167,179,183,179,169, \
        154,136,119,103,91,85,85,91,105,125,146,167, \
        184,193,193,184,165,140,115,91,78,72,74,82, \
        89,99,109,123,136,152,165,175,181,183,177,169, \
        154,136,115,91,70,54,45,48,60,80,103,129, \
        148,157,161,156,146,133,121,111,101,95,89,87, \
        89,95,103,113,125,134,144,150,152,146,136,123, \
        103,85,72,66,68,76,91,109,129,150,169,186, \
        197,197,187,165,131,89,48,14,0,0,10,33, \
        58,76,85,87,80,72,64,64,72,91,115,140, \
        163,177,183,179,163,142,119,95,78,66,62,62, \
        95,113,133,152,169,184,199,209,214,214,210,199, \
        183,161,134,109,87,76,74,83,99,117,136,154, \
        167,177,181,177,167,150,131,109,87,68,52,41, \
        41,54,72,99,127,150,167,173,173,163,150,133, \
        115,101,89,85,85,91,103,121,140,159,179,191, \
        199,197,184,163,136,109,85,70,66,72,83,99, \
        115,131,144,156,167,179,186,187,186,177,163,146, \
        125,103,82,66,54,52,58,70,87,109,129,146, \
        154,154,146,133,117,103,93,89,89,93,99,105, \
        111,115,119,121,123,125,127,127,123,113,97,80, \
        60,45,41,50,68,93,121,146,169,186,197,203, \
        199,186,163,133,93,54,21,0,0,0,10,30, \
        48,60,68,70,70,70,72,80,95,113,131,146, \
        156,157,154,140,123,103,83,70,62,62,70,80, \
        136,156,173,189,201,210,214,212,207,197,184,167, \
        146,123,99,82,72,74,87,109,133,157,177,187, \
        193,191,184,167,146,123,101,83,70,62,58,60, \
        72,87,111,134,154,167,169,163,150,133,113,97, \
        85,80,82,89,101,117,136,154,171,186,195,199, \
        193,181,159,134,105,83,68,66,76,93,115,134, \
        152,165,175,181,184,186,183,177,165,150,131,109, \
        87,72,60,56,60,70,83,101,117,131,140,144, \
        142,133,117,101,87,80,78,85,95,109,119,127, \
        131,127,121,115,109,105,105,101,95,83,68,45, \
        30,21,30,52,83,121,156,183,199,207,207,199, \
        184,159,129,95,62,33,10,0,0,12,27,41, \
        52,60,66,70,76,80,87,97,109,121,129,133, \
        131,125,113,99,83,72,64,64,70,82,99,117, \
        175,189,203,210,212,212,205,195,181,163,146,127, \
        107,91,78,74,78,91,117,144,171,191,205,207, \
        201,186,167,142,117,97,82,76,74,80,87,99, \
        113,131,146,159,167,165,156,138,119,97,83,74, \
        74,82,95,113,133,152,169,183,191,195,193,186, \
        171,152,127,103,83,72,72,83,105,131,154,173, \
        184,189,189,186,179,167,156,142,127,109,89,74, \
        62,54,56,66,82,97,113,127,134,136,133,125, \
        113,101,85,76,70,74,83,99,117,133,142,142, \
        136,125,113,99,91,89,87,87,82,70,50,30, \
        14,14,33,66,107,150,183,203,210,209,197,179, \
        154,125,97,70,48,33,27,30,37,50,60,68, \
        74,78,80,83,89,95,101,107,111,111,111,105, \
        97,87,78,70,64,62,68,80,97,117,138,157, \
        195,205,209,207,201,191,177,161,142,125,109,95, \
        83,78,78,85,101,125,152,179,201,212,214,205, \
        187,163,136,111,91,80,80,85,99,115,129,142, \
        154,163,169,167,161,146,129,109,89,76,72,76, \
        87,105,127,148,167,181,189,193,189,184,171,156, \
        136,117,99,83,76,80,93,115,142,167,187,199, \
        203,197,184,169,150,131,113,97,83,70,60,54, \
        54,60,74,91,111,127,134,136,131,121,107,93, \
        82,74,68,68,76,89,107,127,144,154,154,146, \
        129,111,95,85,80,82,83,85,80,66,45,27, \
        16,23,48,87,131,169,193,205,203,189,169,146, \
        119,95,76,62,56,58,64,76,87,97,103,105, \
        103,101,101,101,101,103,101,99,95,89,82,74, \
        68,62,60,60,64,74,89,107,129,150,169,184, \
        193,193,189,183,171,156,138,123,107,95,87,82, \
        83,89,99,117,136,161,184,203,214,214,203,184, \
        157,131,105,87,80,83,95,115,136,156,169,179, \
        181,177,169,156,138,119,101,85,78,76,83,97, \
        119,140,161,179,189,193,191,184,171,156,138,121, \
        105,93,85,83,89,105,127,150,175,193,205,207, \
        197,183,159,134,109,89,74,62,54,52,52,58, \
        68,83,103,121,136,142,140,129,111,93,76,66, \
        60,62,70,83,99,119,138,154,163,161,150,131, \
        109,89,78,72,76,82,87,89,82,68,48,31, \
        27,39,68,105,144,173,187,187,177,157,134,111, \
        91,80,74,76,85,97,113,125,134,140,140,134, \
        127,119,113,107,103,97,91,83,76,66,60,56, \
        56,58,64,74,85,99,117,134,152,167,179,187, \
        167,163,156,146,133,119,105,95,87,85,87,93, \
        103,117,133,150,167,186,199,207,205,195,175,148, \
        121,97,82,78,85,103,127,152,173,187,195,193, \
        184,169,150,129,109,93,83,80,85,97,115,134, \
        156,175,187,195,195,187,175,157,138,123,107,95, \
        89,87,93,103,119,138,159,179,191,201,199,191, \
        175,150,123,95,74,58,48,45,50,56,68,80, \
        95,113,131,142,146,142,127,107,83,66,54,52, \
        60,74,91,113,134,152,165,169,165,150,127,101, \
        78,64,60,64,74,85,91,89,82,68,52,41, \
        43,60,87,121,148,163,165,156,138,119,101,89, \
        82,83,93,107,125,142,156,165,169,165,157,146, \
        133,119,107,99,91,83,76,70,62,58,58,60, \
        66,76,87,99,113,125,136,146,156,161,165,167, \
        133,129,121,111,101,93,87,87,91,99,109,121, \
        134,148,161,173,183,189,191,187,177,157,133,107, \
        85,74,74,87,109,136,163,184,199,205,199,186, \
        165,142,119,99,85,82,83,95,111,133,154,173, \
        187,197,199,193,181,163,144,125,109,97,89,89, \
        93,103,119,134,152,169,183,189,191,186,175,159, \
        138,113,89,70,56,48,50,56,68,82,95,109, \
        123,134,144,146,140,125,103,82,64,54,52,62, \
        78,101,125,146,161,171,173,165,148,121,91,64, \
        43,37,41,56,72,82,87,85,78,66,58,54, \
        62,80,103,125,138,140,133,117,101,89,83,85, \
        93,107,127,146,163,177,183,183,177,165,152,134, \
        117,103,91,83,80,76,72,70,68,70,76,83, \
        93,105,115,125,131,136,138,140,140,138,136,134, \
        103,101,99,95,91,89,93,101,113,125,138,150, \
        159,167,173,175,175,171,163,148,129,105,83,66, \
        60,66,83,111,140,169,191,205,207,199,184,159, \
        134,109,89,80,80,87,103,125,146,167,186,197, \
        201,199,189,173,154,133,115,99,91,89,93,103, \
        117,133,148,163,177,184,186,183,171,156,140,121, \
        103,85,72,62,60,64,72,83,97,109,121,129, \
        134,138,136,131,117,99,82,68,60,62,72,89, \
        111,134,154,167,175,171,161,140,113,82,52,27, \
        16,19,31,50,66,78,82,80,74,70,68,72, \
        82,95,109,117,117,109,95,83,78,78,87,101, \
        121,142,161,179,187,191,186,177,161,142,125,107, \
        91,82,76,76,78,82,85,89,95,101,107,115, \
        123,129,133,134,133,129,125,119,115,111,107,105, \
        97,99,101,101,103,109,117,129,140,150,159,165, \
        167,167,163,157,148,134,117,95,74,54,39,35, \
        48,74,107,142,173,195,207,207,197,179,152,125, \
        99,82,74,78,89,111,134,159,179,193,201,201, \
        193,181,163,142,123,107,97,93,95,103,117,131, \
        146,159,171,181,183,181,173,157,138,121,103,89, \
        82,76,74,76,83,91,103,113,121,129,131,131, \
        127,123,113,103,91,80,72,70,76,89,105,127, \
        144,159,169,171,165,152,131,105,76,48,23,7, \
        3,12,30,48,64,76,80,80,80,80,83,89, \
        97,103,105,101,91,78,68,66,72,87,109,133, \
        157,177,189,197,193,184,167,146,125,107,91,80, \
        74,74,76,83,93,105,115,125,131,134,138,140, \
        140,138,133,127,119,111,105,99,97,95,93,95, \
        115,121,125,127,131,136,142,150,157,161,163,159, \
        154,146,136,125,109,89,68,43,23,7,7,23, \
        54,93,134,171,195,207,205,193,171,144,117,93, \
        76,70,78,93,117,144,167,186,197,199,195,184, \
        169,148,129,111,99,95,97,105,119,133,146,159, \
        169,175,177,175,169,157,144,125,107,89,80,76, \
        78,83,91,101,111,119,125,129,129,127,121,113, \
        105,97,87,80,74,74,78,87,105,123,140,156, \
        163,165,161,152,136,117,93,70,48,30,16,12, \
        16,30,45,62,76,83,89,91,93,95,99,103, \
        103,101,93,82,68,58,56,66,85,113,142,169, \
        187,201,203,195,179,156,131,105,85,74,68,70, \
        76,85,97,113,127,140,152,157,159,157,154,146, \
        138,129,119,109,101,95,93,93,97,101,105,109, \
        148,152,154,156,156,156,157,157,157,154,146,138, \
        129,119,105,91,74,52,27,3,0,0,0,30, \
        74,119,161,191,205,203,187,165,138,111,87,76, \
        72,80,97,123,150,173,189,197,195,186,171,152, \
        133,113,99,91,93,101,117,133,148,161,169,173, \
        173,169,161,152,140,127,113,97,85,78,78,83, \
        93,103,115,123,129,131,129,123,117,107,99,89, \
        83,76,74,72,76,85,99,117,136,154,163,167, \
        163,152,138,119,99,82,64,50,41,37,37,43, \
        54,64,76,87,97,103,107,109,109,109,107,105, \
        99,89,78,64,56,56,66,87,117,148,177,195, \
        207,207,195,177,148,117,89,68,56,56,64,80, \
        99,117,134,152,165,175,179,179,171,161,148,134, \
        121,109,101,95,93,95,101,109,119,127,136,142, \
        179,179,175,171,165,159,154,148,140,131,121,111, \
        103,93,85,72,54,31,3,0,0,0,7,52, \
        101,146,181,199,199,184,159,131,105,85,76,78, \
        87,107,131,154,177,189,195,189,177,157,134,113, \
        95,85,83,89,105,123,144,161,173,177,177,169, \
        159,148,134,121,111,101,93,87,85,87,93,103, \
        115,123,129,133,131,125,115,103,93,83,78,76, \
        74,76,80,85,95,111,127,144,157,167,167,159, \
        144,125,105,85,70,60,54,54,60,70,80,91, \
        101,109,115,119,123,123,123,121,115,111,105,97, \
        87,76,66,60,62,74,93,121,152,179,197,207, \
        207,193,173,142,111,80,58,45,48,64,85,111, \
        136,159,177,187,193,193,186,175,159,142,125,111, \
        99,93,93,95,103,113,127,140,152,163,171,177, \
        193,186,177,165,154,142,134,125,115,107,99,93, \
        89,87,80,70,50,27,0,0,0,0,37,83, \
        131,169,189,193,181,156,127,101,83,78,82,97, \
        117,138,159,177,186,189,183,167,144,119,97,82, \
        74,78,89,107,131,152,169,181,183,177,163,148, \
        133,117,105,97,93,93,95,99,105,111,119,127, \
        131,133,129,123,113,103,91,82,74,72,74,78, \
        83,93,101,113,125,136,148,157,161,161,152,136, \
        117,95,78,64,58,60,68,82,97,113,127,138, \
        144,146,146,142,138,133,127,119,111,101,93,83, \
        78,72,70,74,87,107,131,157,181,197,203,199, \
        186,165,136,105,78,56,45,50,66,93,123,154, \
        179,197,207,209,203,191,173,152,131,111,97,89, \
        87,93,103,117,131,146,159,173,184,191,195,197, \
        186,175,159,144,129,119,111,105,99,97,95,95, \
        95,95,89,76,56,31,10,0,3,31,72,117, \
        156,181,186,175,152,123,97,82,78,87,105,127, \
        148,165,177,181,179,169,154,133,109,87,74,68, \
        74,89,111,136,159,177,184,184,175,157,138,119, \
        103,93,89,89,95,105,115,125,134,140,142,140, \
        134,125,113,103,91,82,76,72,72,78,85,97, \
        109,119,129,136,144,148,152,152,148,140,127,111, \
        93,78,68,66,72,83,99,119,138,154,165,171, \
        173,167,159,148,138,127,117,107,97,89,83,80, \
        80,82,89,103,123,144,165,184,195,197,189,175, \
        152,127,101,78,60,52,58,76,103,134,165,191, \
        210,220,220,210,191,169,142,117,95,82,78,82, \
        93,109,129,148,165,179,187,195,199,201,199,195, \
        161,146,131,115,105,99,97,99,101,105,107,111, \
        111,109,99,83,62,39,23,21,37,68,107,144, \
        169,179,171,148,121,95,82,80,89,109,133,154, \
        167,175,173,167,154,138,121,101,85,74,70,78, \
        95,117,142,163,181,186,184,171,152,131,109,95, \
        87,87,93,103,117,133,146,156,159,159,152,140, \
        125,109,93,83,78,74,76,80,87,97,109,121, \
        133,140,146,148,146,142,138,133,125,117,105,95, \
        85,82,82,87,101,117,134,152,167,179,184,183, \
        175,163,148,134,121,109,99,91,87,85,85,89, \
        95,107,121,138,156,173,186,193,191,181,161,138, \
        113,91,76,66,64,74,91,117,148,177,203,220, \
        228,224,212,191,163,134,105,82,70,68,76,93, \
        115,140,163,181,191,197,199,197,193,187,181,173, \
        131,119,105,97,93,97,103,111,119,125,129,131, \
        127,119,103,83,62,43,37,48,70,103,136,161, \
        171,165,146,119,95,80,80,91,113,136,157,169, \
        171,165,154,138,123,107,95,85,80,82,89,105, \
        127,150,169,181,186,181,167,148,125,105,91,85, \
        89,99,115,131,148,161,169,173,171,159,144,125, \
        105,91,82,78,82,85,93,101,111,121,129,136, \
        140,142,140,136,129,121,113,109,103,101,99,99, \
        101,105,111,121,134,146,157,169,177,181,177,169, \
        156,140,125,109,99,91,87,87,89,95,101,109, \
        121,133,148,161,175,184,186,183,169,150,125,101, \
        83,72,70,76,89,111,134,163,187,210,224,228, \
        222,207,184,156,125,95,74,62,62,74,93,121, \
        148,173,189,201,203,199,189,179,167,157,150,140, \
        109,103,99,97,101,111,123,133,140,146,144,140, \
        129,113,93,74,58,52,56,74,101,131,154,163, \
        159,142,117,93,80,80,91,113,136,157,167,167, \
        157,142,123,107,95,89,87,89,97,107,123,138, \
        157,171,181,181,173,159,140,121,103,93,91,97, \
        111,129,144,159,171,177,177,173,161,144,125,105, \
        89,82,83,91,101,113,123,129,131,133,131,129, \
        127,123,119,111,103,97,93,93,97,105,113,123, \
        131,138,146,152,156,159,161,163,163,161,154,142, \
        129,113,101,91,85,87,91,99,107,115,123,131, \
        140,150,157,165,171,171,167,154,136,115,93,76, \
        70,72,83,103,127,152,175,197,214,226,226,218, \
        199,175,144,113,85,68,58,62,78,99,127,156, \
        179,197,205,203,193,179,161,146,133,123,119,115, \
        109,111,111,115,123,133,142,150,154,152,144,133, \
        117,97,78,64,58,64,80,103,129,148,157,154, \
        136,115,93,80,80,91,113,136,156,165,161,150, \
        131,111,95,85,85,91,101,113,127,142,154,165, \
        173,177,173,163,150,133,115,103,97,99,109,123, \
        140,156,167,175,177,173,163,152,136,119,101,89, \
        83,87,101,117,131,140,144,142,134,125,115,105, \
        99,93,89,85,83,85,89,99,111,125,140,154, \
        163,169,171,167,161,152,146,140,138,134,129,119, \
        109,99,93,89,93,101,111,121,129,134,138,142, \
        144,146,148,148,148,142,133,119,103,85,72,68, \
        72,87,109,134,159,183,199,212,220,218,209,187, \
        163,133,101,76,60,56,64,83,109,136,163,186, \
        199,205,201,187,167,146,127,111,103,101,103,107, \
        131,134,136,140,142,146,150,150,146,138,127,111, \
        95,80,68,62,68,82,103,125,142,150,146,133, \
        111,91,80,80,91,113,136,156,163,157,142,123, \
        101,85,80,83,95,113,131,148,161,169,175,175, \
        171,161,150,134,121,109,101,101,109,121,136,154, \
        165,173,175,171,161,150,136,123,107,95,85,85, \
        91,107,125,142,154,157,152,140,121,101,85,74, \
        70,68,72,76,83,91,105,121,136,154,167,179, \
        183,183,175,161,146,131,119,113,113,115,115,113, \
        109,105,105,109,115,125,133,140,142,142,138,134, \
        129,125,123,119,115,109,101,89,80,70,68,72, \
        87,109,133,157,177,191,201,205,201,189,171,146, \
        119,89,68,54,54,66,89,117,148,173,193,203, \
        205,195,181,157,133,113,97,91,93,101,113,123, \
        161,163,161,156,150,144,138,131,121,111,99,89, \
        78,70,68,74,85,103,123,136,142,138,125,107, \
        89,78,80,91,113,136,154,161,156,138,115,93, \
        80,78,85,101,123,146,165,179,184,183,175,163, \
        150,134,121,109,101,99,105,117,133,150,165,175, \
        177,173,163,150,134,121,107,97,89,85,87,95, \
        111,129,144,157,161,156,140,119,95,74,58,52, \
        54,64,74,87,101,117,133,148,161,173,183,186, \
        183,175,159,140,119,103,95,97,103,113,121,125, \
        129,131,133,136,140,146,148,146,140,133,123,113, \
        105,99,95,93,89,87,82,76,72,70,74,83, \
        99,121,142,159,171,179,177,171,159,144,123,99, \
        78,60,52,54,70,95,125,156,183,199,207,203, \
        191,171,146,121,101,87,85,91,105,123,140,154, \
        186,183,171,156,138,123,109,99,91,83,80,76, \
        74,78,83,93,107,121,131,134,129,117,101,85, \
        78,80,91,113,136,154,159,154,136,113,89,76, \
        76,85,107,133,159,181,193,197,191,179,159,138, \
        121,105,97,95,99,109,125,144,161,177,183,181, \
        171,156,136,119,105,95,89,89,91,97,107,119, \
        131,144,152,154,148,134,115,93,72,56,48,52, \
        64,80,99,117,133,146,157,167,173,177,175,171, \
        161,148,131,111,93,85,87,97,113,129,142,150, \
        156,157,159,157,156,152,144,134,123,111,101,93, \
        87,83,83,83,83,83,82,80,76,76,80,87, \
        101,115,129,140,144,140,133,121,105,89,74,60, \
        52,50,58,78,103,134,165,189,205,210,203,187, \
        163,136,111,91,82,82,93,113,136,157,175,184, \
        197,183,159,136,111,91,80,72,70,70,74,80, \
        85,95,103,113,121,125,125,117,107,93,83,78, \
        82,95,115,136,152,159,152,134,111,87,74,74, \
        87,111,140,169,191,205,207,197,181,156,131,109, \
        95,89,91,99,115,134,154,171,184,187,184,171, \
        150,129,107,93,87,87,93,103,113,123,133,140, \
        146,146,144,134,123,107,89,74,62,56,60,74, \
        93,115,134,150,159,165,167,167,163,157,152,142, \
        129,115,101,87,82,83,97,117,136,156,167,175, \
        177,175,171,163,152,138,125,111,99,91,85,85, \
        85,89,91,95,97,97,93,89,83,82,80,83, \
        89,97,101,105,101,91,78,64,50,39,33,37, \
        45,64,85,115,144,173,195,209,210,203,184,157, \
        129,101,83,76,80,95,121,148,173,191,203,205, \
        187,161,133,105,80,64,58,60,66,76,85,97, \
        105,113,119,121,119,115,107,97,85,80,78,85, \
        97,117,136,150,156,150,133,111,87,74,74,87, \
        113,144,175,197,212,212,203,183,154,127,101,87, \
        83,89,105,125,144,163,181,189,191,184,167,146, \
        121,99,85,83,89,101,117,131,142,152,154,152, \
        146,134,123,109,95,83,76,72,74,80,93,111, \
        131,150,163,171,171,167,159,150,138,129,119,109, \
        99,91,85,82,87,99,119,142,161,177,184,184, \
        181,173,163,148,133,115,99,87,82,83,87,97, \
        105,113,117,121,119,115,107,99,89,80,76,72, \
        72,72,72,66,58,43,27,12,3,3,14,35, \
        62,93,127,156,183,201,210,210,199,179,152,123, \
        95,78,72,80,99,127,156,184,205,216,216,207, \
        159,129,97,74,58,52,56,66,82,95,107,115, \
        119,121,117,111,103,95,87,82,78,82,89,103, \
        121,136,148,152,146,131,109,89,76,76,89,115, \
        146,177,201,214,214,205,183,154,123,97,83,82, \
        91,111,134,156,175,187,193,191,181,163,140,115, \
        95,82,82,91,109,129,148,161,169,169,161,148, \
        131,113,97,85,80,80,83,91,103,117,133,148, \
        161,171,175,171,161,148,134,121,109,101,95,91, \
        89,87,89,97,109,127,144,163,175,181,181,175, \
        165,152,138,123,107,93,82,78,82,93,107,123, \
        134,142,144,142,136,127,113,101,87,78,72,68, \
        64,60,52,41,25,5,0,0,0,0,19,54, \
        93,133,165,189,205,212,207,193,171,142,115,91, \
        76,72,82,103,131,161,189,212,224,224,210,187, \
        123,91,68,54,50,58,72,87,103,115,123,123, \
        119,113,103,93,85,78,76,78,85,97,111,127, \
        138,146,144,138,123,105,89,80,80,93,117,148, \
        177,199,212,212,201,181,152,123,95,82,82,93, \
        117,142,167,184,195,195,189,175,156,133,109,91, \
        82,83,95,117,140,161,177,183,179,167,150,131, \
        109,91,80,78,83,95,109,125,140,154,163,171, \
        173,171,163,150,134,119,105,95,91,91,93,97, \
        101,107,115,125,136,150,161,169,171,167,159,148, \
        136,125,113,101,91,83,82,87,99,115,134,148, \
        159,161,159,150,138,125,109,97,87,82,80,78, \
        72,64,50,30,7,0,0,0,0,3,43,87, \
        131,167,191,207,210,201,184,159,133,105,83,72, \
        74,85,109,138,169,195,216,228,226,212,187,157, \
        87,64,52,52,60,76,93,109,121,127,125,117, \
        107,95,83,76,72,74,80,91,105,119,133,140, \
        142,138,127,113,99,87,82,85,99,123,150,175, \
        195,207,207,195,175,148,119,95,82,82,95,121, \
        150,175,193,201,199,186,169,146,123,103,87,82, \
        85,99,123,148,171,186,189,184,169,150,127,103, \
        87,78,80,89,105,125,144,159,171,177,177,171, \
        161,150,134,119,103,91,85,85,91,101,113,123, \
        131,138,144,150,156,159,159,156,148,138,127,117, \
        109,103,99,95,93,93,99,109,123,138,154,163, \
        167,163,154,140,127,113,101,95,95,97,99,99, \
        95,82,60,33,5,0,0,0,0,35,80,125, \
        163,189,203,203,193,175,148,121,93,76,68,72, \
        89,115,146,177,201,220,228,226,212,187,156,121, \
        66,54,54,64,82,97,113,121,125,121,113,101, \
        91,82,74,72,76,85,99,113,127,136,140,138, \
        129,117,101,89,82,82,89,107,129,154,177,193, \
        201,197,184,165,140,115,93,82,83,97,123,152, \
        181,199,205,201,184,163,138,115,95,83,82,89, \
        107,129,154,175,189,193,186,169,144,119,97,82, \
        78,82,95,115,138,159,175,183,184,179,167,152, \
        134,117,101,87,80,80,83,95,113,131,146,156, \
        163,165,165,163,157,150,140,129,117,107,101,99, \
        99,101,105,107,111,115,121,129,138,148,156,157, \
        154,146,134,121,109,103,99,103,111,121,127,127, \
        119,99,72,39,10,0,0,0,33,76,119,157, \
        184,195,193,181,159,133,107,82,66,62,70,89, \
        119,152,183,205,222,228,222,207,184,154,119,89, \
        60,62,72,87,101,113,119,119,115,107,97,89, \
        82,80,80,85,93,107,119,131,136,138,133,121, \
        105,91,80,76,82,93,115,138,161,181,191,195, \
        187,173,154,131,109,93,85,87,101,127,156,183, \
        201,209,201,184,157,131,107,89,82,83,95,115, \
        136,159,179,189,191,183,163,138,113,91,78,76, \
        85,101,125,148,169,183,189,186,177,159,140,119, \
        101,87,78,76,78,89,105,125,146,163,177,183, \
        183,177,167,154,140,125,111,99,91,89,91,99, \
        109,119,127,133,136,136,136,136,136,138,136,134, \
        127,119,111,105,101,103,109,121,133,144,148,146, \
        131,107,76,43,19,5,14,39,76,117,152,179, \
        187,184,167,144,117,91,72,60,58,70,91,123, \
        154,184,207,220,224,216,201,177,148,117,89,70, \
        74,83,97,109,117,117,115,109,103,97,91,89, \
        91,93,99,107,117,125,133,134,133,123,111,95, \
        82,74,72,80,97,121,146,169,186,193,191,181, \
        163,140,121,103,93,89,95,111,134,159,184,203, \
        209,201,183,156,127,101,85,82,87,103,125,146, \
        167,181,187,186,175,154,131,105,85,74,74,87, \
        107,133,156,177,187,191,184,171,150,129,107,89, \
        78,74,76,83,99,117,138,157,177,187,193,191, \
        183,167,148,129,109,93,82,78,80,89,103,119, \
        133,146,152,154,150,144,134,125,117,111,107,103, \
        101,99,99,101,107,117,127,140,150,156,154,146, \
        127,99,72,45,31,31,50,80,115,148,173,183, \
        177,159,133,103,78,60,54,58,72,95,127,157, \
        186,205,216,216,207,189,167,140,113,89,76,70, \
        97,109,119,123,119,113,105,99,97,99,101,105, \
        111,119,125,129,131,133,129,123,113,101,87,76, \
        70,72,83,101,127,154,177,191,197,191,175,154, \
        131,109,95,91,95,107,123,144,169,189,203,209, \
        201,183,154,125,97,83,82,91,111,134,157,175, \
        186,187,181,165,144,119,95,78,70,74,89,113, \
        138,163,181,189,189,179,161,140,117,95,82,74, \
        76,83,95,113,133,152,169,184,193,195,191,179, \
        161,140,117,95,80,70,68,74,87,107,127,146, \
        159,167,167,161,148,133,115,99,87,82,80,82, \
        85,93,103,115,127,136,146,152,154,150,142,127, \
        109,85,64,52,50,62,87,117,146,165,175,171, \
        152,127,95,70,54,52,60,78,105,134,163,187, \
        205,212,209,195,177,154,129,107,89,80,78,85, \
        123,131,131,125,117,107,101,101,107,115,125,133, \
        136,138,138,134,131,123,113,103,91,83,76,74, \
        80,91,109,134,159,181,193,197,189,173,148,121, \
        99,87,87,97,115,136,157,179,195,207,209,199, \
        181,152,123,97,82,82,93,117,144,167,184,191, \
        189,177,157,133,107,87,74,68,76,91,117,144, \
        167,183,187,184,173,152,129,107,87,78,76,82, \
        95,111,131,150,167,181,189,193,189,183,169,150, \
        129,107,87,72,64,66,74,89,111,134,154,167, \
        175,173,163,148,129,107,87,72,64,64,70,80, \
        93,109,125,138,148,154,154,148,140,129,115,101, \
        87,74,68,68,78,97,121,144,159,165,159,144, \
        121,93,70,56,54,64,87,115,144,171,193,205, \
        207,199,184,163,140,117,99,85,82,85,95,109, \
        140,140,133,121,111,107,109,119,131,142,150,154, \
        152,144,134,123,113,101,93,85,82,82,83,93, \
        105,123,144,163,181,191,193,186,169,142,117,93, \
        82,83,97,121,146,169,187,201,209,207,195,177, \
        150,121,95,82,82,95,121,150,175,191,199,193, \
        177,152,125,99,80,68,68,78,97,123,148,169, \
        183,186,181,163,142,119,99,83,76,80,91,109, \
        129,150,167,181,189,191,187,181,169,154,136,117, \
        99,83,74,70,72,82,97,117,136,156,167,173, \
        169,159,142,123,101,82,66,60,60,68,82,99, \
        117,134,150,157,159,156,144,129,113,99,89,82, \
        78,78,83,95,111,131,146,156,157,148,133,113, \
        89,72,62,62,74,97,127,156,183,199,207,205, \
        193,173,150,127,105,91,83,85,93,107,123,134, \
        146,136,125,115,111,117,129,144,157,167,169,161, \
        148,131,113,99,87,82,82,83,91,99,113,127, \
        142,157,171,181,186,184,175,159,136,111,89,78, \
        80,95,121,150,177,195,207,209,203,187,169,144, \
        117,93,82,82,97,123,152,181,197,203,195,179, \
        150,121,93,76,68,70,83,105,129,152,171,183, \
        183,173,156,133,111,91,80,78,85,101,123,146, \
        167,183,191,195,191,183,169,154,136,119,105,93, \
        83,80,82,87,97,111,127,140,154,161,163,157, \
        146,131,113,95,80,70,66,70,80,95,113,133, \
        148,159,165,165,156,140,121,101,85,76,74,78, \
        87,99,113,129,144,154,157,152,140,121,101,83, \
        72,68,74,87,111,140,167,191,205,210,203,187, \
        163,136,113,93,83,83,89,103,121,134,146,150, \
        138,123,113,111,119,134,154,171,181,181,171,152, \
        129,103,85,74,72,76,87,101,117,133,148,161, \
        171,179,183,179,173,161,144,125,105,87,78,82, \
        97,123,152,181,199,209,207,197,179,157,134,111, \
        91,82,83,99,125,154,181,199,205,197,179,150, \
        121,93,76,70,76,91,113,136,157,173,179,177, \
        165,146,125,103,85,80,82,93,113,136,161,181, \
        195,201,197,187,173,154,134,117,103,93,87,85, \
        89,95,105,115,127,136,144,150,152,150,142,131, \
        117,103,91,82,78,78,85,97,115,133,150,163, \
        171,173,167,154,134,113,91,76,68,70,80,95, \
        113,131,146,157,165,163,152,134,113,93,78,72, \
        74,83,101,127,152,179,197,210,210,201,183,156, \
        125,99,82,74,80,93,113,133,150,159,159,152, \
        121,107,105,115,134,156,177,187,187,177,154,127, \
        97,74,62,60,72,89,111,133,152,167,179,184, \
        186,183,173,161,146,129,113,97,85,82,85,101, \
        127,156,183,201,209,205,189,169,146,123,103,89, \
        83,87,103,127,154,181,197,205,197,179,150,119, \
        93,78,74,82,101,123,146,163,173,175,169,156, \
        136,115,95,82,80,85,101,123,148,173,191,203, \
        205,199,184,163,140,117,99,89,83,83,89,97, \
        109,121,133,140,146,148,146,142,134,123,113,101, \
        93,87,85,89,95,107,119,136,152,165,175,179, \
        175,165,150,129,105,83,70,64,68,82,103,125, \
        144,159,169,173,167,154,133,111,89,76,72,80, \
        95,117,140,165,186,203,210,209,197,175,146,115, \
        87,68,64,74,95,121,144,161,171,169,157,140, \
        101,95,105,125,152,175,187,187,177,154,123,93, \
        68,54,54,66,89,117,144,165,181,189,191,187, \
        179,165,150,133,117,103,93,87,89,95,111,134, \
        159,184,201,209,201,186,161,134,111,95,85,85, \
        93,111,134,157,181,195,201,193,175,148,119,93, \
        78,76,87,109,133,154,169,175,171,159,144,125, \
        105,87,80,80,91,109,134,159,183,199,207,207, \
        197,179,154,129,103,85,78,76,83,93,107,121, \
        133,142,146,148,144,138,129,117,105,95,89,85, \
        87,93,103,115,129,140,154,165,175,179,177,171, \
        159,142,123,101,82,68,64,72,87,109,133,154, \
        169,177,175,167,152,131,107,87,76,74,85,105, \
        129,154,177,193,205,209,203,187,167,136,105,78, \
        58,54,66,89,121,150,171,183,179,165,142,119, \
        87,93,113,140,167,183,186,173,150,119,87,62, \
        48,50,64,89,119,148,173,187,193,191,183,171, \
        154,136,121,109,99,95,97,101,113,129,148,169, \
        187,203,207,199,181,156,127,103,87,83,89,103, \
        123,144,165,184,195,195,187,169,142,115,91,78, \
        78,91,115,140,161,175,177,169,152,131,111,93, \
        82,78,83,97,119,144,169,187,203,209,205,191, \
        173,146,119,95,80,72,74,83,99,115,129,140, \
        146,148,144,136,125,113,101,91,83,82,83,91, \
        105,119,134,148,159,169,175,177,175,169,159,146, \
        131,113,95,82,74,72,80,97,119,140,159,171, \
        175,171,159,142,123,101,83,74,78,91,113,140, \
        165,186,201,207,203,193,177,154,127,99,72,54, \
        50,60,83,117,150,175,187,186,169,144,119,97, \
        85,103,129,156,175,179,169,144,115,82,58,43, \
        45,62,89,121,150,173,187,191,186,173,157,140, \
        123,109,101,99,101,109,121,134,150,165,183,195, \
        203,205,195,177,150,123,97,83,82,91,111,134, \
        157,177,191,197,193,183,161,136,111,89,80,80, \
        93,117,144,167,179,181,169,148,123,99,83,76, \
        76,87,105,129,154,177,193,203,205,199,184,163, \
        140,115,93,78,74,78,89,105,121,134,142,144, \
        140,133,123,109,97,87,80,78,80,87,101,117, \
        136,154,167,175,179,177,171,163,154,142,129,115, \
        101,89,83,82,85,95,111,131,150,163,171,169, \
        161,146,129,111,93,80,74,78,95,119,148,173, \
        193,205,205,199,184,165,140,117,91,72,56,54, \
        62,83,115,148,173,187,187,173,148,119,95,82, \
        95,121,146,165,173,165,142,113,80,56,41,43, \
        60,87,119,148,169,183,183,175,159,142,123,109, \
        99,95,99,109,125,140,157,173,186,197,205,207, \
        201,189,169,144,117,93,82,82,93,117,144,169, \
        187,199,201,193,179,154,129,105,87,80,83,97, \
        121,146,167,181,181,167,146,119,93,78,72,76, \
        91,113,138,163,183,195,203,199,189,173,154,131, \
        109,93,83,82,87,101,117,131,138,140,136,129, \
        117,105,93,83,78,74,78,85,97,115,134,154, \
        171,184,189,186,177,163,148,133,119,107,97,89, \
        85,85,91,101,113,129,146,159,169,171,165,150, \
        133,113,95,83,76,76,83,99,125,152,177,193, \
        203,201,191,175,152,129,107,87,74,66,66,76, \
        93,121,148,171,186,186,173,148,119,93,80,80, \
        115,138,159,167,161,142,115,83,60,45,45,62, \
        85,115,142,161,171,171,159,144,125,109,95,91, \
        93,101,117,136,157,177,193,205,210,212,207,195, \
        181,159,134,111,91,80,82,97,121,150,175,195, \
        205,205,193,175,150,123,99,83,80,85,103,125, \
        150,169,181,179,167,144,117,91,76,72,80,99, \
        123,150,173,189,199,201,191,179,159,140,121,105, \
        95,89,93,103,117,131,142,146,142,131,115,99, \
        87,78,72,72,76,85,97,115,133,154,171,187, \
        197,199,191,177,156,133,111,95,85,80,80,85, \
        93,103,117,133,146,159,169,173,171,159,140,121, \
        99,83,76,74,80,91,109,133,156,177,191,197, \
        193,181,161,138,117,97,85,78,78,83,95,113, \
        133,156,173,183,181,167,144,117,93,78,78,91, \
        133,152,161,156,140,117,89,70,56,56,68,87, \
        113,134,150,157,154,142,127,109,95,87,85,93, \
        107,127,148,171,191,207,216,220,214,205,187,169, \
        144,121,101,85,80,83,99,125,152,179,197,207, \
        205,191,171,144,115,93,80,78,89,107,131,154, \
        171,179,177,163,140,115,91,78,76,85,107,133, \
        159,183,199,205,199,186,167,146,127,109,99,95, \
        99,107,121,134,148,156,156,146,129,107,85,72, \
        64,64,70,82,97,115,134,154,173,187,201,207, \
        207,195,177,150,123,95,78,68,68,74,87,101, \
        119,134,150,161,171,175,173,165,150,131,109,89, \
        76,70,76,87,105,125,146,165,181,189,189,183, \
        167,148,125,105,91,83,83,91,103,119,136,152, \
        167,179,183,177,161,138,113,89,76,76,87,109, \
        146,154,150,136,115,93,78,70,70,80,95,115, \
        131,140,142,136,123,107,93,83,80,85,97,117, \
        138,161,183,201,214,222,220,212,197,177,154,129, \
        107,87,78,78,85,103,129,156,181,197,205,201, \
        186,163,136,109,87,76,78,91,113,136,159,173, \
        179,173,157,136,111,91,78,78,91,115,142,171, \
        191,205,209,201,184,159,134,113,97,91,95,105, \
        121,138,154,165,171,167,154,133,107,82,64,56, \
        60,72,89,111,134,154,173,187,201,209,210,207, \
        193,175,146,117,89,68,58,62,74,91,113,134, \
        154,167,175,179,177,169,156,136,117,95,78,70, \
        68,80,97,121,144,165,181,189,191,186,173,154, \
        133,113,95,85,83,91,105,123,140,157,171,183, \
        186,184,173,156,131,105,83,72,74,85,107,129, \
        148,142,129,111,93,82,78,83,93,107,121,129, \
        133,129,119,105,91,78,72,76,85,103,127,150, \
        173,191,207,216,218,214,205,186,165,138,113,91, \
        78,70,74,87,109,134,159,181,193,199,193,177, \
        154,127,101,82,74,76,91,115,140,163,177,179, \
        169,152,131,107,89,80,82,95,121,148,177,197, \
        210,210,201,183,156,127,103,89,85,93,111,131, \
        152,169,183,186,179,163,138,109,83,64,56,62, \
        78,101,125,150,171,187,199,207,209,205,197,184, \
        165,140,113,87,68,60,64,80,101,127,152,171, \
        184,187,186,177,159,140,119,97,80,66,62,68, \
        83,107,134,161,184,199,205,201,187,167,144,121, \
        101,87,83,85,97,117,138,159,177,187,191,189, \
        183,167,146,121,95,76,66,70,83,103,125,140, \
        136,121,103,87,80,80,89,103,117,127,131,127, \
        119,105,91,80,70,68,74,89,111,134,159,183, \
        199,210,214,212,203,191,173,150,125,101,82,70, \
        66,74,89,113,138,161,181,189,191,184,167,144, \
        119,95,78,72,78,93,117,142,165,177,179,167, \
        148,125,103,85,80,83,99,125,152,179,197,209, \
        209,197,177,150,123,97,83,83,93,113,136,161, \
        181,191,193,186,169,144,115,87,70,64,70,87, \
        113,138,161,181,195,201,203,199,191,181,165,148, \
        129,107,87,74,68,76,91,115,142,167,187,199, \
        201,191,177,154,129,103,80,62,54,54,64,85, \
        113,144,173,197,212,218,210,193,169,140,115,93, \
        83,83,91,107,129,152,173,187,197,197,189,177, \
        156,134,109,85,68,60,66,82,103,125,138,142, \
        117,99,83,78,80,89,105,121,129,131,123,111, \
        95,82,72,68,70,80,97,119,144,169,189,203, \
        209,209,201,189,173,156,134,113,93,78,70,70, \
        80,95,119,142,163,177,184,183,173,154,133,109, \
        89,76,74,82,97,121,144,163,175,175,163,144, \
        119,97,83,80,87,105,129,156,179,195,203,201, \
        187,169,142,117,93,82,82,93,115,140,165,184, \
        195,197,187,171,144,117,91,76,72,80,99,125, \
        150,171,187,195,197,193,183,169,154,138,123,107, \
        93,83,78,80,89,107,133,157,183,199,210,209, \
        199,179,152,121,93,70,52,45,50,64,87,117, \
        150,181,205,220,226,218,201,175,142,113,91,82, \
        85,99,119,142,163,183,197,203,199,186,167,142, \
        117,91,72,58,54,62,78,101,125,138,142,134, \
        97,82,76,80,89,105,119,127,127,117,103,87, \
        74,68,70,78,91,111,133,156,177,193,203,205, \
        199,187,173,156,138,121,103,89,82,78,80,91, \
        107,127,146,163,173,177,171,159,142,121,101,85, \
        78,78,87,105,127,148,165,173,171,157,138,115, \
        93,82,82,91,111,136,161,181,193,195,189,175, \
        154,131,107,89,80,82,93,117,142,165,183,191, \
        191,183,165,140,115,93,80,78,89,111,136,159, \
        179,189,191,186,177,161,144,125,109,93,83,78, \
        76,80,89,105,125,148,171,191,207,214,212,201, \
        179,150,119,89,68,54,48,54,70,93,125,156, \
        184,205,220,224,218,201,175,144,113,91,82,87, \
        105,129,154,177,191,201,203,195,181,156,129,99, \
        76,58,48,48,58,78,101,125,140,144,134,117, \
        83,78,80,91,105,117,123,121,111,97,82,72, \
        68,74,87,107,129,150,169,186,195,201,197,187, \
        173,156,138,121,107,97,91,89,91,99,111,125, \
        140,156,165,169,167,157,146,129,111,95,83,80, \
        85,97,115,136,154,167,171,165,150,131,109,91, \
        82,82,95,117,144,167,184,193,191,181,161,138, \
        115,95,82,78,82,97,119,142,163,179,184,181, \
        169,154,133,111,91,82,82,95,117,144,167,183, \
        189,186,175,157,138,117,97,82,70,62,62,70, \
        82,99,119,140,161,181,197,207,210,207,195,175, \
        148,119,91,72,62,62,70,87,111,136,163,186, \
        203,212,214,207,191,169,140,113,91,82,87,107, \
        134,161,184,199,205,201,189,171,146,117,87,64, \
        48,39,43,58,78,101,123,138,142,136,119,99, \
        80,82,93,105,115,119,115,105,91,78,70,70, \
        80,97,121,144,167,184,195,199,197,187,173,156, \
        136,121,107,99,95,97,103,111,121,133,146,157, \
        165,169,165,157,146,131,117,103,93,87,87,95, \
        109,127,146,161,169,169,161,144,125,105,89,82, \
        85,101,123,150,173,187,195,189,175,152,127,101, \
        83,74,74,83,101,123,144,163,173,175,167,154, \
        138,119,103,89,83,87,101,125,150,171,186,187, \
        181,163,142,117,93,76,62,54,52,56,68,83, \
        105,129,152,173,187,199,203,201,193,181,161,136, \
        113,91,76,72,78,91,111,134,156,177,193,205, \
        207,201,189,173,152,129,107,89,82,87,105,134, \
        163,187,203,205,197,183,159,134,107,80,58,43, \
        39,45,62,82,101,121,134,138,133,119,101,85, \
        82,91,103,113,115,111,99,85,76,72,76,89, \
        109,134,159,181,195,203,203,193,179,159,138,119, \
        103,93,91,97,107,119,131,144,156,165,173,175, \
        171,163,150,134,119,105,97,93,93,99,109,123, \
        138,154,165,171,167,156,138,119,101,87,83,91, \
        107,129,154,177,189,193,186,169,144,117,93,76, \
        70,74,87,107,129,150,163,169,167,156,138,121, \
        105,95,87,89,95,111,133,154,175,186,186,177, \
        156,131,103,78,62,50,48,50,60,74,93,115, \
        138,161,179,189,195,193,187,175,159,140,121,101, \
        85,78,78,89,109,133,156,177,193,203,207,203, \
        189,171,150,129,109,93,82,80,87,107,133,161, \
        186,201,203,193,175,150,123,97,76,58,50,48, \
        56,70,89,107,121,129,131,125,111,97,83,78, \
        89,99,109,111,105,93,82,76,76,83,99,123, \
        146,171,189,203,207,201,189,171,146,123,103,87, \
        82,85,97,115,133,150,165,175,183,184,181,173, \
        157,140,123,107,97,93,95,103,113,125,136,150, \
        161,167,167,161,148,131,113,97,87,87,97,113, \
        136,159,179,189,191,181,161,136,109,85,72,68, \
        76,91,113,136,156,167,169,161,146,127,109,95, \
        87,89,95,107,125,144,163,179,186,184,171,150, \
        123,95,72,56,50,50,60,72,87,107,127,146, \
        165,179,187,187,183,171,156,136,117,99,87,78, \
        76,82,97,121,146,173,191,207,212,210,199,183, \
        157,131,105,85,74,72,78,89,109,134,161,183, \
        195,197,186,165,140,115,91,74,64,60,64,74, \
        85,101,113,123,125,121,113,101,87,80,76,80, \
        93,101,103,97,89,80,74,78,89,109,134,157, \
        181,195,205,205,197,183,159,136,111,91,80,76, \
        82,97,119,142,163,179,189,193,189,183,169,152, \
        131,111,97,87,89,95,109,125,138,150,159,165, \
        167,161,152,138,121,103,91,87,89,101,121,140, \
        161,179,186,186,173,152,127,99,80,68,68,80, \
        99,123,144,161,169,169,157,140,119,99,87,83, \
        89,103,121,140,159,175,184,187,183,167,144,117, \
        91,72,60,56,62,74,89,105,123,136,150,163, \
        173,177,175,167,154,136,119,99,85,76,72,76, \
        85,103,127,154,179,197,209,212,207,193,173,146, \
        117,89,68,58,60,72,91,115,140,163,183,191, \
        189,179,157,133,107,87,76,72,74,82,93,105, \
        117,125,127,123,113,101,87,76,70,68,74,83, \
        95,97,93,85,78,76,82,95,119,144,167,186, \
        199,203,199,187,171,148,125,103,85,76,76,83, \
        101,125,148,171,186,195,195,189,179,161,142,121, \
        101,87,80,82,93,111,129,146,157,165,165,161, \
        154,140,125,109,93,85,83,89,103,123,142,159, \
        173,179,175,163,140,115,89,70,62,66,83,107, \
        133,154,169,173,169,156,134,113,93,82,83,93, \
        113,134,157,177,187,193,191,183,163,140,115,89, \
        74,66,70,80,93,109,125,136,144,152,156,157, \
        159,156,148,136,121,105,89,80,72,72,78,91, \
        109,131,154,175,191,201,203,197,183,161,134,105, \
        80,58,48,52,68,91,121,148,169,184,189,184, \
        171,148,123,99,83,78,80,89,101,115,127,133, \
        134,131,121,107,89,74,62,56,58,66,78,87, \
        93,91,85,82,80,87,103,125,150,173,189,199, \
        199,191,177,157,134,115,95,83,78,82,91,109, \
        131,152,173,186,193,193,186,171,154,133,111,93, \
        80,74,78,87,105,125,142,156,161,159,152,142, \
        127,113,97,85,80,80,87,103,121,138,152,161, \
        165,159,148,129,105,80,62,56,64,82,109,138, \
        161,175,177,169,152,131,107,89,82,83,97,121, \
        146,171,191,203,205,197,183,159,134,109,89,76, \
        74,82,95,113,131,142,148,148,146,142,138,134, \
        131,125,117,107,97,87,82,80,82,89,101,115, \
        134,152,169,181,186,186,179,163,144,121,95,74, \
        56,48,52,68,93,125,154,175,187,189,181,163, \
        138,115,93,80,80,87,103,121,136,144,148,144, \
        134,119,101,82,64,50,43,45,54,66,80,89, \
        91,91,89,91,97,113,133,154,175,189,195,191, \
        183,163,144,123,103,89,82,82,87,101,119,138, \
        156,171,181,186,184,177,161,144,125,105,89,78, \
        72,74,83,97,115,131,142,148,146,138,127,113, \
        99,89,82,78,82,89,101,115,129,138,144,144, \
        138,129,113,93,76,60,54,62,82,111,140,163, \
        177,179,167,148,125,103,87,80,85,103,127,156, \
        183,203,214,214,203,184,157,129,103,85,76,78, \
        89,107,129,146,156,157,152,138,127,115,107,105, \
        103,101,99,95,93,91,93,97,105,113,123,134, \
        146,156,163,165,163,154,140,125,105,87,70,60, \
        54,60,76,99,129,156,179,189,189,177,157,131, \
        105,85,76,78,91,113,134,152,161,161,152,136, \
        115,93,74,54,39,31,31,37,52,66,80,87, \
        95,99,105,111,123,140,157,173,184,186,183,169, \
        152,131,111,95,85,83,85,95,109,127,142,156, \
        167,173,173,171,163,152,138,121,105,91,80,74, \
        74,78,87,101,113,121,127,125,121,111,101,91, \
        83,80,82,85,93,101,111,119,123,125,121,115, \
        107,95,85,74,64,62,70,87,113,140,163,177, \
        179,167,146,121,97,83,82,89,109,134,163,191, \
        212,222,222,209,186,156,125,97,80,72,78,91, \
        113,134,154,163,163,154,134,113,93,83,80,82, \
        87,93,99,103,107,111,117,121,127,131,134,136, \
        140,142,140,136,131,119,107,93,82,72,68,68, \
        74,89,109,133,156,177,186,186,173,152,125,99, \
        80,72,76,91,117,142,161,173,171,157,134,109, \
        83,62,43,31,23,21,25,35,48,64,78,87]
        return

    def initInGameOptions(self):
        gc = CyGlobalContext()
        mmap = gc.getMap()
		
        #Land Percentage
        selectionID = mmap.getCustomMapOption(0)
        if selectionID == 0:
            self.landPercent = 0.18
        elif selectionID == 1:
            self.landPercent = 0.20
        elif selectionID == 2:
            self.landPercent = 0.22
        elif selectionID == 3:
            self.landPercent = 0.24		
        elif selectionID == 4:
            self.landPercent = 0.26	
        elif selectionID == 5:
            self.landPercent = 0.28	
        elif selectionID == 6:
            self.landPercent = 0.30	
        elif selectionID == 7:
            self.landPercent = 0.32	
        elif selectionID == 8:
            self.landPercent = 0.34	
        elif selectionID == 9:
            self.landPercent = 0.36	
        elif selectionID == 10:
            self.landPercent = 0.38	
        elif selectionID == 11:
            self.landPercent = 0.40
		
        #Landforms
        selectionID = mmap.getCustomMapOption(1)
        if selectionID == 0:
            self.hmMaxGrain = 8
            self.hmNoiseLevel = 1.5
        elif selectionID == 1:
            self.hmMaxGrain = 8
            self.hmNoiseLevel = 1.75
        elif selectionID == 2:
            self.hmMaxGrain = 16
            self.hmNoiseLevel = 1
        elif selectionID == 3:
            self.hmMaxGrain = 16
            self.hmNoiseLevel = 1.26

        #Land Zone
        selectionID = mmap.getCustomMapOption(2)
        if selectionID == 0:
			self.outerAttenuationRadius = 64.0
        elif selectionID == 1:
			self.outerAttenuationRadius = 66.0	
        elif selectionID == 2:
			self.outerAttenuationRadius = 68.0	
        elif selectionID == 3:
			self.outerAttenuationRadius = 70.0	
        elif selectionID == 4:
			self.outerAttenuationRadius = 72.0	
        elif selectionID == 5:
			self.outerAttenuationRadius = 74.0	
			
        # Polar Region Size
        selectionID = mmap.getCustomMapOption(3)
        if selectionID == 0:
			self.polarIceRadiusPercent = 0.06
			self.innerAttenuationRadius = 36.0
			self.minShieldWallRadius = 40.0
        elif selectionID == 1:
			self.polarIceRadiusPercent = 0.12
			self.innerAttenuationRadius = 41.0
			self.minShieldWallRadius = 45.0
        elif selectionID == 2:
			self.polarIceRadiusPercent = 0.18
			self.innerAttenuationRadius = 46.0
			self.minShieldWallRadius = 50.0
	
        return	
		
mc = MapConstants()

class PythonRandom :
    def __init__(self):
        return
    def seed(self):
        #Python randoms are not usable in network games.
        if mc.UsePythonRandom:
            self.usePR = True
        else:
            self.usePR = False
        if self.usePR and CyGame().isNetworkMultiPlayer():
            print "Detecting network game. Setting UsePythonRandom to False."
            self.usePR = False
        if self.usePR:
            # Python 'long' has unlimited precision, while the random generator
            # has 53 bits of precision, so I'm using a 53 bit integer to seed the map!
            seed() #Start with system time
            seedValue = randint(0,9007199254740991)
            seed(seedValue)
            self.seedString = "Random seed (Using Python rands) for this map is %(s)20d" % {"s":seedValue}
            
##            seedValue = 4316490043753041
##            seed(seedValue)
##            self.seedString = "Pre-set seed (Using Pyhon rands) for this map is %(s)20d" % {"s":seedValue}     
        else:
            gc = CyGlobalContext()
            self.mapRand = gc.getGame().getMapRand()
            
            seedValue = self.mapRand.get(65535,"Seeding mapRand - FairWeather.py")
            self.mapRand.init(seedValue)
            self.seedString = "Random seed (Using getMapRand) for this map is %(s)20d" % {"s":seedValue}            
            
##            seedValue = 56870
##            self.mapRand.init(seedValue)
##            self.seedString = "Pre-set seed (Using getMapRand) for this map is %(s)20d" % {"s":seedValue}
            
        print self.seedString
        return
    def random(self):
        if self.usePR:
            return random()
        else:
            #This formula is identical to the getFloat function in CvRandom. It
            #is not exposed to Python so I have to recreate it.
            fResult = float(self.mapRand.get(65535,"Getting float -FairWeather.py"))/float(65535)
#            print fResult
            return fResult
    def randint(self,rMin,rMax):
        #if rMin and rMax are the same, then return the only option
        if rMin == rMax:
            return rMin
        #returns a number between rMin and rMax inclusive
        if self.usePR:
            return randint(rMin,rMax)
        else:
            #mapRand.get() is not inclusive, so we must make it so
            return rMin + self.mapRand.get(rMax + 1 - rMin,"Getting a randint - FairWeather.py")
#Set up random number system for global access
PRand = PythonRandom()

################################################################################
## Global functions
################################################################################

def errorPopUp(message):
    gc = CyGlobalContext()
    iPlayerNum = 0
    for iPlayer in range(gc.getMAX_PLAYERS()):
        player = gc.getPlayer(iPlayer)
        if player.isAlive():
            iPlayerNum = iPlayerNum + 1
            if player.isHuman():
                text = message + "\n\n" + "\n" + PRand.seedString
                popupInfo = CyPopupInfo()
                popupInfo.setButtonPopupType(ButtonPopupTypes.BUTTONPOPUP_PYTHON)
                popupInfo.setText(text)
                popupInfo.setOnClickedPythonCallback("")
                popupInfo.addPythonButton("Ok","")
                popupInfo.addPopup(iPlayer)
                
#This function converts x and y to an index.
def GetIndex(x,y):
    #Check X for wrap
    if mc.WrapX == True:
        xx = x % mc.width
    elif x < 0 or x >= mc.width:
        return -1
    else:
        xx = x
    #Check y for wrap
    if mc.WrapY == True:
        yy = y % mc.height
    elif y < 0 or y >= mc.height:
        return -1
    else:
        yy = y

    i = yy * mc.width + xx
    return i

def GetHmIndex(x,y):
    #Check X for wrap
    if mc.WrapX == True:
        xx = x % mc.hmWidth
    elif x < 0 or x >= mc.hmWidth:
        return -1
    else:
        xx = x
    #Check y for wrap
    if mc.WrapY == True:
        yy = y % mc.hmHeight
    elif y < 0 or y >= mc.hmHeight:
        return -1
    else:
        yy = y

    i = yy * mc.hmWidth + xx
    return i

#Handles arbitrary size
def GetIndexGeneral(x,y,width,height):
    #Check X for wrap
    if mc.WrapX == True:
        xx = x % width
    elif x < 0 or x >= width:
        return -1
    else:
        xx = x
    #Check y for wrap
    if mc.WrapY == True:
        yy = y % height
    elif y < 0 or y >= height:
        return -1
    else:
        yy = y

    i = yy * width + xx
    return i

def getRadius(x,y):
    centerX = mc.width/2.0
    centerY = mc.height/2.0
    return math.sqrt(pow(float(y - centerY),2) + pow(float(x - centerX),2))

#Always wraps for dune texture
def GetDuneTextureIndex(x,y,width,height):
    xx = x % width
    yy = y % height

    i = yy * width + xx
    return i


#This function scales a float map so that all values are between
#0.0 and 1.0.
def NormalizeMap(fMap,width,height):
    #find highest and lowest points
    maxAlt = 0.0
    minAlt = 0.0
    for y in range(height):
        for x in range(width):
            plot = fMap[GetIndexGeneral(x,y,width,height)]
            if plot > maxAlt:
                maxAlt = plot
            if plot < minAlt:
                minAlt = plot
    #normalize map so that all altitudes are between 1 and 0
    #first add minAlt to all values if necessary
    if minAlt < 0.0:
        for y in range(height):
            for x in range(width):
                fMap[GetIndexGeneral(x,y,width,height)] -= minAlt
    #add minAlt to maxAlt also before scaling entire map
    maxAlt -= minAlt
    scaler = 1.0/maxAlt
    for y in range(height):
        for x in range(width):
            fMap[GetIndexGeneral(x,y,width,height)] = fMap[GetIndexGeneral(x,y,width,height)] * scaler              
    return
def ShrinkMap(largeMap,lWidth,lHeight,sWidth,sHeight):
    smallMap = array('d')
    yScale = float(lHeight)/float(sHeight)
    xScale = float(lWidth)/float(sWidth)
##    print "yScale= %f, xScale= %f" % (yScale,xScale)
    for y in range(sHeight):
        for x in range(sWidth):
##            print "x = %d, y = %d" % (x,y)
            weights = 0.0
            contributors = 0.0
            yyStart = int(y * yScale)
            yyStop = int((y + 1) * yScale)
            if yyStop < ((y + 1) * yScale):
                yyStop += 1
            for yy in range(yyStart,yyStop):
                xxStart = int(x * xScale)
                xxStop = int((x + 1) * xScale)
                if xxStop < ((x + 1) * xScale):
                    xxStop += 1
                for xx in range(xxStart,xxStop):
##                    print "  xx = %d, yy = %d" % (xx,yy)
                    weight = GetWeight(x,y,xx,yy,xScale,yScale)
##                    print "  weight = %f" % weight
                    i = yy * lWidth + xx
##                    print "  i = %d" % i
                    contributor = largeMap[i]
##                    print "  contributer = %f" % contributor
                    weights += weight
                    contributors += weight * contributor
##            print " final height = %f" % (contributors/weights)        
            smallMap.append(contributors/weights)
                    
    return smallMap
def GetWeight(x,y,xx,yy,xScale,yScale):
    xWeight = 1.0
##    print "   xScale = %f" % xScale
##    print "   x * xScale = %f, xx = %f" % ((x * xScale),xx)
    if float(xx) < x * xScale:
##        print "   first"
        xWeight = 1.0 - ((x * xScale) - float(xx))
    elif float(xx + 1) > (x + 1) * xScale:
##        print "   second"
        xWeight = ((x + 1) * xScale) - float(xx)
##    print "   xWeight = %f" % xWeight
        
    yWeight = 1.0
##    print "   yScale = %f" % yScale
##    print "   y * yScale = %f, yy = %f" % ((y * yScale),yy)
    if float(yy) < y * yScale:
##        print "   first"
        yWeight = 1.0 - ((y * yScale) - float(yy))
    elif float(yy + 1) > (y + 1) * yScale:
##        print "   second"
        yWeight = ((y + 1) * yScale) - float(yy)
##    print "   yWeight = %f" % yWeight
        
    return xWeight * yWeight


def AngleDifference(a1,a2):
    diff = a1 - a2
    while(diff < -180.0):
        diff += 360.0
    while(diff > 180.0):
        diff -= 360.0
    return diff
def AppendUnique(theList,newItem):
    if IsInList(theList,newItem) == False:
        theList.append(newItem)
    return

def IsInList(theList,newItem):
    itemFound = False
    for item in theList:
        if item == newItem:
            itemFound = True
            break
    return itemFound

def DeleteFromList(theList,oldItem):
    for n in range(len(theList)):
        if theList[n] == oldItem:
            del theList[n]
            break
    return  
    
def ShuffleList(theList):
        preshuffle = list()
        shuffled = list()
        numElements = len(theList)
        for i in range(numElements):
            preshuffle.append(theList[i])
        for i in range(numElements):
                n = PRand.randint(0,len(preshuffle)-1)
                shuffled.append(preshuffle[n])
                del preshuffle[n]
        return shuffled
    
def GetInfoType(string):
	cgc = CyGlobalContext()
	return cgc.getInfoTypeForString(string)
    
def GetDistance(x,y,dx,dy):
    distance = math.sqrt(abs((float(x - dx) * float(x - dx)) + (float(y - dy) * float(y - dy))))
    return distance

def GetOppositeDirection(direction):
    opposite = mc.L
    if direction == mc.N:
        opposite = mc.S
    elif direction == mc.S:
        opposite = mc.N
    elif direction == mc.E:
        opposite = mc.W
    elif direction == mc.W:
        opposite = mc.E
    elif direction == mc.NW:
        opposite = mc.SE
    elif direction == mc.SE:
        opposite = mc.NW
    elif direction == mc.SW:
        opposite = mc.NE
    elif direction == mc.NE:
        opposite = mc.SW
    return opposite

def GetXYFromDirection(x,y,direction):
    xx = x
    yy = y
    if direction == mc.N:
        yy += 1
    elif direction == mc.S:
        yy -= 1
    elif direction == mc.E:
        xx += 1
    elif direction == mc.W:
        xx -= 1
    elif direction == mc.NW:
        yy += 1
        xx -= 1
    elif direction == mc.NE:
        yy += 1
        xx += 1
    elif direction == mc.SW:
        yy -= 1
        xx -= 1
    elif direction == mc.SE:
        yy -= 1
        xx += 1
    return xx,yy    

##This function is a general purpose value tuner. It finds a value that will be greater
##than or less than the desired percent of a whole map within a given tolerance. Map values
##should be between 0 and 1. To exclude parts of the map, set them to value 0.0
def FindValueFromPercent(mmap,width,height,percent,tolerance,greaterThan):
    inTolerance = False
    #to speed things up a little, lets take some time to find the middle value
    #in the dataset and use that to begin our search
    minV = 100.0
    maxV = 0.0
    totalCount = 0
    for i in range(height*width):
        if mmap[i] != 0.0:
            totalCount += 1
            if minV > mmap[i]:
                minV = mmap[i]
            if maxV < mmap[i]:
                maxV = mmap[i]
    mid = (maxV - minV)/2.0 + minV
##    overMinCount = 0
##    equalMinCount = 0
##    for i in range(height*width):
##        if mmap[i] > minV:
##            overMinCount += 1
##        elif mmap[i] == minV:
##            equalMinCount += 1
##    print "--------------------------------------------------------------"
##    print "totalCount = %d" % totalCount
##    print "overMinCount = %d" % overMinCount
##    print "equalMinCount = %d" % equalMinCount
##    print "starting threshold = %f" % mid
##    print "desired percent = %f" % percent
##    print "minV = %f, maxV = %f" % (minV,maxV)
    
    threshold = mid
    thresholdChange = mid
    iterations = 0
    lastAdded = False
    while not inTolerance:
        iterations += 1
        if(iterations > 500):
            print "can't find value within tolerance, end value = "
            print "threshold = %f, thresholdChange = %f" % (threshold, thresholdChange)
            break #close enough
        matchCount = 0
        for i in range(height*width):
            if mmap[i] != 0.0:
                if greaterThan == True:
                    if(mmap[i] > threshold):
                        matchCount += 1
                else:
                    if(mmap[i] < threshold):  
                        matchCount += 1
##        print "current threshold = %f" % threshold
##        print "current thresholdChange = %f" % thresholdChange
##        print "matchCount = %d" % matchCount
        currentPercent = float(matchCount)/float(totalCount)
##        print "currentPercent = %f" % currentPercent
        if currentPercent < percent + tolerance and \
           currentPercent > percent - tolerance:
            inTolerance = True
        elif greaterThan == True:
            if currentPercent < percent:
##                print "threshold subtract"
                threshold -= thresholdChange
                if lastAdded:
                    #only cut thresholdChange when direction is changed
                    thresholdChange = thresholdChange/2.0
                lastAdded = False
            else:
##                print "threshold add"
                threshold += thresholdChange
                if not lastAdded:
                    thresholdChange = thresholdChange/2.0
                lastAdded = True
        else:
            if currentPercent > percent:
                threshold += thresholdChange
                if not lastAdded:
                    thresholdChange = thresholdChange/2.0
                lastAdded = True
            else:
                threshold -= thresholdChange
                if lastAdded:
                    thresholdChange = thresholdChange/2.0
                lastAdded = False
##        print "--------------"

        #at this point value should be in tolerance or close to it
##    print "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    return threshold
def isWaterMatch(x,y):
    result = hm.isBelowSeaLevel(x,y)
##    print "match function results - x = %d,y = %d,result = %d" % (x,y,result)
    return result

class HeightMap :
    def __init__(self):
        return
    
    def generateHeightMap(self):
        self.heightMap = array('d')
        self.terrainField = array('d')
        for i in range(mc.hmWidth * mc.hmHeight):
            self.heightMap.append(0.0)
            self.terrainField.append(0.0)

        self.generateMidpointDisplacement(self.heightMap,mc.hmMaxGrain)
        self.generateMidpointDisplacement(self.terrainField,mc.hmMaxTFGrain)
        return
    
    def checkMaxGrain(self,grain):
        #hm map dimensions(minus 1 if no wrapping) must be evenly divisible
        #by max grain
        ok = True
        width = mc.hmWidth
        height = mc.hmHeight
        if mc.WrapX == False:
            width -= 1
        if mc.WrapY == False:
            height -= 1
            
        if 0 != width % grain:
            ok = False
        if 0 != height % grain:
            ok = False

        if ok == False:
            raise ValueError, "height map dimesions not divisible by mc.hmMaxGrain. also check wrapping options"
            
        return
    
    def generateMidpointDisplacement(self,hmap,grain):
        self.checkMaxGrain(grain)
        
        #make list of map plots that aren't on margin for each
        #map quadrant. We want to place the initial peaks randomly, but we
        #also want to ensure fairly even distribution so that
        #not all the peaks are on one side of the map. For this purpose
        #we will treat each map quadrant separately.

        peaksNWList = list()
        peaksNEList = list()
        peaksSWList = list()
        peaksSEList = list()
        middleX = mc.hmWidth/2
        middleY = mc.hmHeight/2
        for y in range(0,mc.hmHeight,grain):
            for x in range(0,mc.hmWidth,grain):
                if x < middleX and y < middleY:
                    peaksSWList.append((x,y))
                elif x >= middleX and y < middleY:
                    peaksSEList.append((x,y))
                elif x < middleX and y >= middleY:
                    peaksNWList.append((x,y))
                elif x >= middleX and y >= middleY:
                    peaksNEList.append((x,y))
        #shuffle the lists
        peaksNWList = ShuffleList(peaksNWList)
        peaksNEList = ShuffleList(peaksNEList)
        peaksSWList = ShuffleList(peaksSWList)
        peaksSEList = ShuffleList(peaksSEList)

        #place desired number of peaks in each quadrant
        totalNonMargin = len(peaksNWList)
        totalNonMargin += len(peaksNEList)
        totalNonMargin += len(peaksSWList)
        totalNonMargin += len(peaksSEList)
        
        count = max(1,int(float(totalNonMargin) * mc.hmInitialPeakPercent * 0.25))
        print "peak count = %d" % (count)
        for n in range(count):
            x,y = peaksNWList[n]
            i = GetHmIndex(x,y)
            hmap[i] = 1.0
            print "%d,%d = 1.0" % (x,y)
            
            x,y = peaksNEList[n]
            i = GetHmIndex(x,y)
            hmap[i] = 1.0
            
            x,y = peaksSWList[n]
            i = GetHmIndex(x,y)
            hmap[i] = 1.0
            
            x,y = peaksSEList[n]
            i = GetHmIndex(x,y)
            hmap[i] = 1.0
            
        self.printInitialPeaks()

        #Now use a diamond-square algorithm(sort of) to generate the rest
        currentGrain = float(grain)
        while currentGrain > 1.0:
            #h is scalar for random displacement
            h = (currentGrain/float(grain)) * float(mc.hmNoiseLevel)
            #First do the 'square' pass
            for y in range(0,mc.hmHeight,int(currentGrain)):
                for x in range(0,mc.hmWidth,int(currentGrain)):
                    #on the square pass, GetHmIndex should handle all wrapping needs
                    topLeft = GetHmIndex(x,y)
                    topRight = GetHmIndex(x + int(currentGrain),y)
                    if topRight == -1:
                        continue #this means no wrap in x direction
                    bottomLeft = GetHmIndex(x,y + int(currentGrain))
                    if bottomLeft == -1:
                        continue #this means no wrap in y direction
                    bottomRight = GetHmIndex(x + int(currentGrain),y + int(currentGrain))
                    middle = GetHmIndex(x + int(currentGrain/2.0),y + int(currentGrain/2.0))
                    average = (hmap[topLeft] + hmap[topRight] \
                    + hmap[bottomLeft] + hmap[bottomRight])/4.0
                    displacement = h * PRand.random() - h/2.0
                    hmap[middle] = average + displacement
                    #now add that heuristic to the four points to diminish
                    #artifacts. We don't need this on the diamond pass I don't think
                    displacement = h * PRand.random() - h/2.0
                    hmap[topLeft] += displacement
                    displacement = h * PRand.random() - h/2.0
                    hmap[topRight] += displacement
                    displacement = h * PRand.random() - h/2.0
                    hmap[bottomLeft] += displacement
                    displacement = h * PRand.random() - h/2.0
                    hmap[bottomRight] += displacement
            #Now do the 'diamond' pass, there are two diamonds for each x.
            #Possible wrapping is a big complication on this pass. Sorry!
            for y in range(0,mc.hmHeight,int(currentGrain)):
                for x in range(0,mc.hmWidth,int(currentGrain)):
                    #first do the right facing diamond
                    left = GetHmIndex(x,y)
                    right = GetHmIndex(x + int(currentGrain),y)
                    if right != -1: #if we're off map at this point go to next diamond
                        average = hmap[left] + hmap[right]
                        contributers = 2 #each diamond may have two or three contributers, 2 so far
                        top = GetHmIndex(x + int(currentGrain/2.0),y - int(currentGrain/2.0))
                        if top != -1:
                            contributers += 1
                            average += hmap[top]
                        bottom = GetHmIndex(x + int(currentGrain/2.0),y + int(currentGrain/2.0))
                        if bottom != -1:
                            contributers += 1
                            average += hmap[bottom]
                        average = average/float(contributers)
                        middle = GetHmIndex(x + int(currentGrain/2.0),y)
                        displacement = h * PRand.random() - h/2.0
                        hmap[middle] = average + displacement
                    #now do the down facing diamond
                    top = GetHmIndex(x,y)
                    bottom = GetHmIndex(x,y + int(currentGrain))
                    if bottom != -1:
                        average = hmap[top] + hmap[bottom]
                        contributers = 2
                        right = GetHmIndex(x + int(currentGrain/2.0),y + int(currentGrain/2.0))
                        if right != -1:
                            contributers += 1
                            average += hmap[right]
                        left = GetHmIndex(x - int(currentGrain/2.0),y + int(currentGrain/2.0))
                        if left != -1:
                            contributers += 1
                            average += hmap[left]
                        average = average/float(contributers)
                        middle = GetHmIndex(x,y + int(currentGrain/2.0))
                        displacement = h * PRand.random() - h/2.0
                        hmap[middle] = average + displacement
                        
            currentGrain = currentGrain/2.0

        NormalizeMap(hmap,mc.hmWidth,mc.hmHeight)
        
        return
    def adjustArrakisAltitude(self):
        centerX = float(mc.hmWidth)/2.0
        centerY = float(mc.hmHeight)/2.0
        for y in range(mc.hmHeight):
            for x in range(mc.hmWidth):
                i = GetHmIndex(x,y)
                distance = math.sqrt(pow(float(y - centerY),2) + pow(float(x - centerX),2))
                if distance < mc.innerAttenuationRadius:
                    self.heightMap[i] *= distance/mc.innerAttenuationRadius
                elif distance > mc.outerAttenuationRadius:
                    self.heightMap[i] *= mc.outerAttenuationRadius/distance
                if self.heightMap[i] < 0.0:
                    self.heightMap[i] = 0.0

                               
        NormalizeMap(self.heightMap,mc.hmWidth,mc.hmHeight)

    def makeShieldWall(self):
        #make shield wall
        radius = mc.minShieldWallRadius + ((mc.maxShieldWallRadius - mc.minShieldWallRadius)/2.0)
        radiusRate = 0.0
        oldX = -1
        oldY = -1
        for angle in range(0,360,2):
            x = int(radius * math.cos(math.radians(float(angle))) + float(mc.hmWidth)/2.0)
            y = int(radius * math.sin(math.radians(float(angle))) + float(mc.hmHeight)/2.0)
            if oldX == x and oldY == y:
                continue
            i = GetHmIndex(x,y)
            if self.isBelowSeaLevel(x,y):
                continue
            oldX = x
            oldY = y
            self.heightMap[i] = 1.0
            for direction in range(1,9,1):
                xx,yy = GetXYFromDirection(x,y,direction)
                ii = GetHmIndex(xx,yy)
                if self.heightMap[ii] < 0.8 and not self.isBelowSeaLevel(xx,yy):
                    self.heightMap[ii] = 0.8

            if PRand.random() < 0.5:
                if radiusRate < 1.0:
                    radiusRate += 0.5
            else:
                if radiusRate > -1.0:
                    radiusRate -= 0.5

            if radius + radiusRate < mc.minShieldWallRadius or \
            radius + radiusRate > mc.maxShieldWallRadius:
                radiusRate = radiusRate * -1.0

            radius += radiusRate         
        
    def calculateSeaLevel(self):
        self.seaLevel = FindValueFromPercent(self.heightMap,mc.hmWidth,mc.hmHeight,mc.landPercent,0.02,True)
        return
    
    def isBelowSeaLevel(self,x,y):
        i = GetHmIndex(x,y)
##        print "heightMap = %f at %d,%d" % (self.heightMap[i],x,y)
##        print "seaLevel = %f" % self.seaLevel
        if self.heightMap[i] < self.seaLevel:
##            print "True"
            return True
##        print "False"
        return False
    
    ## This function returns altitude in relation to sea level with
    ## 0.0 being seaLevel and 1.0 being highest altitude
    def getAltitudeAboveSeaLevel(self,x,y):
        i = GetHmIndex(x,y)
        if i == -1:
            return 0.0
        altitude = self.heightMap[i]
        if altitude < self.seaLevel:
            return 0.0
        altitude = 1.0/(1.0 - self.seaLevel) * (altitude - self.seaLevel)
        return altitude

    def setAltitudeAboveSeaLevel(self,x,y,altitude):
        i = GetHmIndex(x,y)
        if i == -1:
            return
        self.heightMap[i] = ((1.0 - self.seaLevel) * altitude) + self.seaLevel
        
##    def Erode(self):
##        for y in range(mc.hmHeight):
##            for x in range(mc.hmWidth):
##                alt = self.getAltitudeAboveSeaLevel(x,y)
##                if alt > 0:
##                    eroded = pow(alt,mc.erosionPower)
##                    self.setAltitudeAboveSeaLevel(x,y,eroded)
                    
    def printInitialPeaks(self):
        lineString = "midpoint displacement peaks and margins"
        print lineString
        if not mc.WrapY:
            adjustedHeight = mc.hmHeight - 1
        else:
            adjustedHeight = mc.hmHeight - mc.hmMaxGrain
        for y in range(adjustedHeight,-1,-mc.hmMaxGrain):
            lineString = ""
            for x in range(0,mc.hmWidth,mc.hmMaxGrain):
                i = GetHmIndex(x,y)
                if self.heightMap[i] == 1.0:
                    lineString += "1"
                elif self.heightMap[i] == 0.0:
                    lineString += "0"
            print lineString
        lineString = " "
        print lineString
        
    def printHeightMap(self):
        lineString = "Height Map"
        print lineString
        for y in range(mc.hmHeight - 1,-1,-1):
            lineString = ""
            for x in range(0,mc.hmWidth,1):
                i = GetHmIndex(x,y)
                mapLoc = int((self.heightMap[i] - self.seaLevel)/(1.0 - self.seaLevel) * 10)
                #mapLoc = int(self.heightMap[i] * 10)
                if self.heightMap[i] < self.seaLevel:
                    lineString += '.'
                else:
                    lineString += chr(mapLoc + 48)
            print lineString
        lineString = " "
        print lineString
        
    def printPlateMap(self,plateMap):
        lineString = "Plate Map"
        print lineString
        for y in range(mc.hmHeight - 1,-1,-1):
            lineString = ""
            for x in range(0,mc.hmWidth,1):
                i = GetHmIndex(x,y)
                mapLoc = plateMap[i].plateID
                if mapLoc > 40:
                    mapLoc = 41
                lineString += chr(mapLoc + 48)
            print lineString
        lineString = " "
        print lineString
        
def isSmallWaterMatch(x,y):
    return sm.isBelowSeaLevel(x,y)

def isAboveSeaLevelMatch(x,y):
    return sm.isAboveSeaLevel(x,y)	

class SmallMaps :
    def __init__(self):
        return
    def initialize(self):
        self.prepareDuneMap()
        self.newHeightMap = ShrinkMap(hm.heightMap,mc.hmWidth ,mc.hmHeight,mc.width,mc.height)
        self.terrainField = ShrinkMap(hm.terrainField,mc.hmWidth,mc.hmHeight,mc.width,mc.height)
##        newAverageTempMap = ShrinkMap(cm.averageTempMap,mc.hmWidth,mc.hmHeight,mc.width,mc.height)

        self.heightMap = array('d')
##        self.rainFallMap = array('d')
##        self.averageTempMap = array('d')

        for y in range(mc.height):
            for x in range(mc.width):
                oldX = x
                i = GetIndexGeneral(oldX,y,mc.width,mc.height)
                if i != -1:
                    self.heightMap.append(self.newHeightMap[i])
                else:
                    self.heightMap.append(hm.seaLevel - 0.000001)

        #Smooth coasts so there are fewer hills on coast
        for y in range(mc.height):
            for x in range(mc.width):
                if self.isBelowSeaLevel(x,y):
                    i = GetIndex(x,y)
                    self.heightMap[i] = hm.seaLevel - 0.000001
                    
        self.fillInLakes()
        self.removeSmallIslands()

        self.createPlotMap()
        self.printPlotMap()
        self.createTerrainMap()

    def fillInLakes(self):
        #smaller lakes need to be filled in again because the map
        #shrinker sometimes creates lakes.
        am = Areamap(mc.width,mc.height,True,True)
        am.defineAreas(isSmallWaterMatch)
##        am.PrintAreaMap()
        oceanID = am.getOceanID()
        for y in range(mc.height):
            for x in range(mc.width):
                i = GetIndex(x,y)
                if self.isBelowSeaLevel(x,y) and am.areaMap[i] != oceanID:
                    #check the size of this body of water, if too small,
                    #change to land
                    for a in am.areaList:
                        if a.ID == am.areaMap[i] and a.size < mc.minInlandSeaSize:
                            self.heightMap[i] = hm.seaLevel
        
        return

    def removeSmallIslands(self):
        am = Areamap(mc.width,mc.height,True,True)
        am.defineAreas(isAboveSeaLevelMatch)
        for y in range(mc.height):
            for x in range(mc.width):
                i = GetIndex(x,y)
                if self.isAboveSeaLevel(x,y):
                    for a in am.areaList:
                        if a.ID == am.areaMap[i] and a.size < 4:
                            self.heightMap[i] = hm.seaLevel - 10
        
        return
    
    def prepareDuneMap(self):
        duneTex = array('d')
        for i in mc.dunedata:
            height = float(i)/256.0
            duneTex.append(height)
        print "len(mc.dunedata) = %d" % len(mc.dunedata)
        print "width * height = %d" % (mc.duneWidth * mc.duneHeight)
        if mc.duneScale == 1.0:
            self.duneWidth = mc.duneWidth 
            self.duneHeight = mc.duneHeight
            self.duneTexture = duneTex
        elif mc.duneScale < 1.0:
            self.duneWidth = int(mc.duneWidth * mc.duneScale)
            self.duneHeight = int(mc.duneHeight * mc.duneScale)
            print "duneWidth/height = %d,%d" % (self.duneWidth,self.duneHeight)
            self.duneTexture = ShrinkMap(duneTex,mc.duneWidth ,mc.duneHeight,self.duneWidth,self.duneHeight)
        else:
            raise Exception, "duneScale must be 1.0 or less"
            
    def isBelowSeaLevel(self,x,y):
        i = GetIndex(x,y)
        if self.heightMap[i] < hm.seaLevel:
            return True
        return False
        
    def isAboveSeaLevel(self,x,y):
        i = GetIndex(x,y)
        if self.heightMap[i] >= hm.seaLevel:
            return True
        return False
    
    ## This function returns altitude in relation to sea level with
    ## 0.0 being seaLevel and 1.0 being highest altitude
    def getAltitudeAboveSeaLevel(self,x,y):
        i = GetIndex(x,y)
        if i == -1:
            return 0.0
        altitude = self.heightMap[i]
        if altitude < hm.seaLevel:
            return 0.0
        altitude = 1.0/(1.0 - hm.seaLevel) * (altitude - hm.seaLevel)
        return altitude
    

    def createPlotMap(self):
        self.plotMap = array('i')
        #create height difference map to allow for tuning
        diffMap = array('d')
        for i in range(0,mc.height*mc.width):
            diffMap.append(0.0)
        #I tried using a deviation from surrounding average altitude
        #to determine hills and peaks but I didn't like the
        #results. Therefore I an using lowest neighbor
        for y in range(mc.height):
            for x in range(mc.width):
                i = GetIndex(x,y)
                myAlt = self.heightMap[i]
                minAlt = 1.0
                for direction in range(1,9,1):
                    xx,yy = GetXYFromDirection(x,y,direction)
                    ii = GetIndex(xx,yy)
                    if ii == -1:
                        continue
                    if self.heightMap[ii] < minAlt:
                        minAlt = self.heightMap[ii]
                diffMap[i] = myAlt - minAlt

        NormalizeMap(diffMap,mc.width,mc.height)
                    
        peakHeight = FindValueFromPercent(diffMap,mc.width,mc.height,mc.PeakPercent,0.001,True)
        hillHeight = FindValueFromPercent(diffMap,mc.width,mc.height,mc.HillPercent,0.001,True)

        self.plotMap = array('i')
        #initialize map with 0CEAN
        for i in range(0,mc.height*mc.width):
            self.plotMap.append(mc.OCEAN)
        for y in range(mc.height):
            for x in range(mc.width):
                i = GetIndex(x,y)
                altDiff = diffMap[i]
                if self.heightMap[i] < hm.seaLevel:
                    self.plotMap[i] = mc.OCEAN
                elif altDiff < peakHeight:
                    self.plotMap[i] = mc.LAND
                else:
                     self.plotMap[i] = mc.PEAK

        #Randomize high altitude areas
        for y in range(mc.height):
            for x in range(mc.width):
                i = GetIndex(x,y)
                if self.plotMap[i] == mc.LAND:
                    randomNum = PRand.random()
                    if randomNum < mc.PeakChanceAtOne * self.getAltitudeAboveSeaLevel(x,y):
                        self.plotMap[i] = mc.PEAK
##                    elif randomNum < mc.HillChanceAtOne * self.getAltitudeAboveSeaLevel(x,y):
##                        self.plotMap[i] = mc.HILLS

        # davidlallen: pick least connected peak of 2x2 block and flatten
        for yul in range(mc.height):
            for xul in range(mc.width):
                i = GetIndex(xul,yul)
                if self.plotMap[i] == mc.PEAK:
                    xur, yur = GetXYFromDirection(xul, yul, mc.E)
                    if self.plotMap[GetIndex(xur,yur)] != mc.PEAK: continue
                    xlr, ylr = GetXYFromDirection(xul, yul, mc.SE)
                    if self.plotMap[GetIndex(xlr,ylr)] != mc.PEAK: continue
                    xll, yll = GetXYFromDirection(xul, yul, mc.S)
                    if self.plotMap[GetIndex(xll,yll)] != mc.PEAK: continue
                    # This is a 2x2 block.  Count adjacent peaks for each
                    sul = 0 ; sur = 0; sll = 0 ; slr = 0 ; smin = 4
                    for dir in [mc.W, mc.NW, mc.N]:
                        x, y = GetXYFromDirection(xul, yul, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sul = sul + 1
                    for dir in [mc.N, mc.NE, mc.E]:
                        x, y = GetXYFromDirection(xur, yur, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sur = sur + 1
                    for dir in [mc.E, mc.SE, mc.S]:
                        x, y = GetXYFromDirection(xlr, ylr, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: slr = slr + 1
                    for dir in [mc.S, mc.SW, mc.W]:
                        x, y = GetXYFromDirection(xll, yll, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sll = sll + 1
                    # List members who tie for fewest neighbors, and pick one
                    if sul < smin: smin = sul
                    if sur < smin: smin = sur
                    if slr < smin: smin = slr
                    if sll < smin: smin = sll
                    choices = []
                    if sul == smin: choices.append([xul, yul])
                    if sur == smin: choices.append([xur, yur])
                    if slr == smin: choices.append([xlr, ylr])
                    if sll == smin: choices.append([xll, yll])
                    x, y = choices[PRand.randint(0,len(choices)-1)]
                    # Flatten it
                    self.plotMap[GetIndex(x,y)] = mc.LAND
					
        # deliverator: if you have 2x2 block of flat land raise one to Mesa (PEAK)	
        for yul in range(mc.height):
            for xul in range(mc.width):
                i = GetIndex(xul,yul)
                if self.plotMap[i] == mc.LAND:
                    xur, yur = GetXYFromDirection(xul, yul, mc.E)
                    if self.plotMap[GetIndex(xur,yur)] != mc.LAND: continue
                    xlr, ylr = GetXYFromDirection(xul, yul, mc.SE)
                    if self.plotMap[GetIndex(xlr,ylr)] != mc.LAND: continue
                    xll, yll = GetXYFromDirection(xul, yul, mc.S)
                    if self.plotMap[GetIndex(xll,yll)] != mc.LAND: continue
                    # This is a 2x2 block.  Count adjacent peaks for each
                    sul = 0 ; sur = 0; sll = 0 ; slr = 0 ; smin = 4
                    for dir in [mc.W, mc.NW, mc.N]:
                        x, y = GetXYFromDirection(xul, yul, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sul = sul + 1
                    for dir in [mc.N, mc.NE, mc.E]:
                        x, y = GetXYFromDirection(xur, yur, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sur = sur + 1
                    for dir in [mc.E, mc.SE, mc.S]:
                        x, y = GetXYFromDirection(xlr, ylr, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: slr = slr + 1
                    for dir in [mc.S, mc.SW, mc.W]:
                        x, y = GetXYFromDirection(xll, yll, dir)
                        if self.plotMap[GetIndex(x,y)] == mc.PEAK: sll = sll + 1
                    # List members who tie for fewest neighbors
                    if sul < smin: smin = sul
                    if sur < smin: smin = sur
                    if slr < smin: smin = slr
                    if sll < smin: smin = sll
                    if smin == 0:
					    choices = []
					    if sul == smin: choices.append([xul, yul])
					    if sur == smin: choices.append([xur, yur])
					    if slr == smin: choices.append([xlr, ylr])
					    if sll == smin: choices.append([xll, yll])
					    x, y = choices[PRand.randint(0,len(choices)-1)]
					    # Raise it
					    self.plotMap[GetIndex(x,y)] = mc.PEAK					
        return

    def hasWaterNeighbor(self,x,y):
        for direction in range(1,9,1):
            xx,yy = GetXYFromDirection(x,y,direction)
            ii = GetIndex(xx,yy)
            if self.plotMap[ii] == mc.OCEAN:
                return True
        return False
    
    def hasOnlyHillNeighbors(self,x,y):
        for direction in range(1,5,1):
            xx,yy = GetXYFromDirection(x,y,direction)
            ii = GetIndex(xx,yy)
            if self.plotMap[ii] != mc.HILLS:
                return False
        return True
    
    def createTerrainMap(self):
        self.terrainMap = array('i')

        for i in range(0,mc.height*mc.width):
            if self.plotMap[i] == mc.OCEAN:
                self.terrainMap.append(mc.OCEAN)
            else:
                self.terrainMap.append(mc.PLAINS)
                                 
        snowHeight = FindValueFromPercent(self.terrainField,mc.width,mc.height,mc.SnowPercent,0.001,True)
        grassHeight = FindValueFromPercent(self.terrainField,mc.width,mc.height,mc.GrassPercent,0.001,True)
        plainsHeight = FindValueFromPercent(self.terrainField,mc.width,mc.height,mc.PlainsPercent,0.001,True)

        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                if self.plotMap[i] == mc.OCEAN:
                    continue
                if self.terrainField[i] >= snowHeight:
                    self.terrainMap[i] = mc.SNOW
                elif self.terrainField[i] >= grassHeight:
                    self.terrainMap[i] = mc.GRASS
                elif self.terrainField[i] >= plainsHeight:
                    if self.heightMap[i] < .75:
                        if self.hasWaterNeighbor(x,y):
                            self.terrainMap[i] = mc.GRASS
                        else:
                            self.terrainMap[i] = mc.PLAINS
                            self.plotMap[i] = mc.HILLS
                else:
                    if self.heightMap[i] < .75:
                        if self.hasWaterNeighbor(x,y):
                            self.terrainMap[i] = mc.GRASS
                        else:
                            self.terrainMap[i] = mc.SALT
                            self.plotMap[i] = mc.HILLS

        #put coast around continents        
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                for direction in range(1,9,1):
                    xx,yy = GetXYFromDirection(x,y,direction)
                    ii = GetIndex(xx,yy)
                    if self.plotMap[i] == mc.OCEAN and self.plotMap[ii] != mc.OCEAN:
                        self.terrainMap[i] = mc.COAST
                #create salt
                if self.plotMap[i] == mc.HILLS:
                    if self.hasOnlyHillNeighbors(x,y):
                        self.terrainMap[i] = mc.SALT
                    
                
        self.createDistanceMap()
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                d = GetDuneTextureIndex(x,y,self.duneWidth,self.duneHeight)
                height = self.duneScalerMap[i] * self.duneTexture[d]
                if float(getRadius(x,y))/float(mc.width) < mc.polarIceRadiusPercent:
                    if CyGame().getSorenRandNum(100, "polarSinkLandChance") < 88:
                        self.terrainMap[i] = mc.POLAR_PLAINS
                        self.plotMap[i] = mc.HILLS
                else:
                    if height > mc.duneHillAlt:
                        self.terrainMap[i] = mc.DESERT
                        self.plotMap[i] = mc.LAND
                    elif height > mc.duneLandAlt:
                        self.terrainMap[i] = mc.DESERT
                        self.plotMap[i] = mc.LAND

        # put polar land around sink               
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                for direction in range(1,9,1):
                    xx,yy = GetXYFromDirection(x,y,direction)
                    ii = GetIndex(xx,yy)
                    if (self.terrainMap[i] == mc.OCEAN or self.terrainMap[i] == mc.DESERT) and self.plotMap[ii] != mc.OCEAN and self.plotMap[ii] != mc.LAND and self.terrainMap[ii] == mc.POLAR_PLAINS:
                        self.terrainMap[i] = mc.POLAR
                        self.plotMap[i] = mc.LAND

        #put polar coast around the polar stuff                
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                for direction in range(1,9,1):
                    xx,yy = GetXYFromDirection(x,y,direction)
                    ii = GetIndex(xx,yy)
                    if (self.terrainMap[i] == mc.OCEAN or self.terrainMap[i] == mc.DESERT) and self.plotMap[ii] != mc.OCEAN and self.terrainMap[ii] == mc.POLAR and self.plotMap[ii] == mc.LAND:
                        self.terrainMap[i] = mc.POLAR_COAST
                        self.plotMap[i] = mc.OCEAN

        #put polar coast around the polar stuff                
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                for direction in range(1,9,1):
                    xx,yy = GetXYFromDirection(x,y,direction)
                    ii = GetIndex(xx,yy)
                    if (self.terrainMap[i] == mc.OCEAN or self.terrainMap[i] == mc.DESERT) and self.plotMap[ii] == mc.OCEAN and self.terrainMap[ii] == mc.POLAR_COAST:
                        self.terrainMap[i] = mc.OCEAN
                        self.plotMap[i] = mc.OCEAN

        return
    
    def createDistanceMap(self):
        distanceMap = array('d')
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                distanceMap.append(1000.0)
                
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)

                for yy in range(y - mc.distanceFilterSize/2,y + mc.distanceFilterSize/2 + 1,1):
                    for xx in range(x - mc.distanceFilterSize/2,x + mc.distanceFilterSize/2 + 1,1):
                        ii = GetIndex(xx,yy)
                        if ii == -1:
                            continue
                        if self.plotMap[i] != mc.OCEAN:
                            distance = math.sqrt(pow(float(y - yy),2) + pow(float(x - xx),2))
                            if distance < distanceMap[ii]:
                                distanceMap[ii] = distance
                                
        self.duneScalerMap = array('d')
        for y in range(0,mc.height):
            for x in range(0,mc.width):
                i = GetIndex(x,y)
                if distanceMap[i] > mc.duneMaxHeightDistance:
                    self.duneScalerMap.append(1.0)
                else:
                    self.duneScalerMap.append(distanceMap[i]/mc.duneMaxHeightDistance)

    def printHeightMap(self):
        lineString = "Height Map"
        print lineString
        for y in range(mc.height - 1,-1,-1):
            lineString = ""
            for x in range(0,mc.width,1):
                i = GetIndexGeneral(x,y,mc.width,mc.height)
                mapLoc = int((self.heightMap[i] - hm.seaLevel)/(1.0 - hm.seaLevel) * 10)
                #mapLoc = int(self.heightMap[i] * 10)
                if self.heightMap[i] < hm.seaLevel:
                    lineString += '.'
                else:
                    lineString += chr(mapLoc + 48)
            print lineString
        lineString = " "
        print lineString
        
    def printPlotMap(self):
        print "Plot Map"
        for y in range(mc.height - 1,-1,-1):
            lineString = ""
            for x in range(mc.width):
                mapLoc = self.plotMap[GetIndex(x,y)]
                if mapLoc == mc.PEAK:
                    lineString += 'A'
                elif mapLoc == mc.HILLS:
                    lineString += 'n'
                elif mapLoc == mc.LAND:
                    lineString += '+'
                else:
                    lineString += '.'
            print lineString
        lineString = " "
        print lineString
    def printTerrainMap(self):
        print "Terrain Map"
        for y in range(mc.height - 1,-1,-1):
            lineString = ""
            for x in range(mc.width):
                mapLoc = self.terrainMap[GetIndex(x,y)]
                if mapLoc == mc.OCEAN:
                    lineString += ','
                elif mapLoc == mc.COAST:
                    lineString += '.'
                elif mapLoc == mc.DESERT:
                    lineString += 'D'
                elif mapLoc == mc.GRASS:
                    lineString += '+'
                elif mapLoc == mc.MARSH:
                    lineString += 'M'
                elif mapLoc == mc.PLAINS:
                    lineString += 'P'
                elif mapLoc == mc.SNOW:
                    lineString += 'I'
            print lineString
        lineString = " "
        print lineString

class Areamap :
    def __init__(self,width,height,b8connected,bSwitch4Or8OnFalseMatch):
        self.mapWidth = width
        self.mapHeight = height
        self.areaMap = array('i')
        self.b8connected = b8connected
        self.bSwitch4Or8OnFalseMatch = bSwitch4Or8OnFalseMatch
        #initialize map with zeros
        for i in range(0,self.mapHeight*self.mapWidth):
            self.areaMap.append(0)
        return
    def defineAreas(self,matchFunction):
#        self.areaSizes = array('i')
##        starttime = time.clock()
        self.areaList = list()
        areaID = 0
        #make sure map is erased in case it is used multiple times
        for i in range(0,self.mapHeight*self.mapWidth):
            self.areaMap[i] = 0
#        for i in range(0,1):
        for i in range(0,self.mapHeight*self.mapWidth):
            if self.areaMap[i] == 0: #not assigned to an area yet
                areaID += 1
                areaSize,match = self.fillArea(i,areaID,matchFunction)
                area = Area(areaID,areaSize,match)
                self.areaList.append(area)

##        endtime = time.clock()
##        elapsed = endtime - starttime
##        print "defineAreas time ="
##        print elapsed
##        print

        return

##    def isWater(self,x,y,coastIsLand):
##        #coastIsLand = True means that we are trying to find continents that
##        #are not connected by coasts to the main landmasses, allowing us to
##        #find continents suitable as a 'New World'. Otherwise, we
##        #are just looking to fill in lakes and coast needs to be considered
##        #water in that case
##        ii = self.getIndex(x,y)
##        if ii == -1:
##            return False
##        if coastIsLand:
##            if hm.plotMap[ii] == hm.OCEAN and terr.terrainMap[ii] != terr.COAST:
##                return True
##            else:
##                return False
##        else:
##            if hm.isBelowSeaLevel(x,y):
##                return True
##            else:
##                return False
##            
##        return False
    def getAreaByID(self,areaID):
        for i in range(len(self.areaList)):
            if self.areaList[i].ID == areaID:
                return self.areaList[i]
        return None
    def getOceanID(self):
#        self.areaList.sort(key=operator.attrgetter('size'),reverse=True)
        self.areaList.sort(lambda x,y:cmp(x.size,y.size))
        self.areaList.reverse()
        for a in self.areaList:
            if a.water == True:
                return a.ID
                        
    def getIndex(self,x,y):
        #Check X for wrap
        if mc.WrapX == True:
            xx = x % self.mapWidth
        elif x < 0 or x >= self.mapWidth:
            return -1
        else:
            xx = x
        #Check y for wrap
        if mc.WrapY == True:
            yy = y % self.mapHeight
        elif y < 0 or y >= self.mapHeight:
            return -1
        else:
            yy = y

        i = yy * self.mapWidth + xx
        return i
    
    def fillArea(self,index,areaID,matchFunction):
        #first divide index into x and y
        y = index/self.mapWidth
        x = index%self.mapWidth
        #We check 8 neigbors for land,but 4 for water. This is because
        #the game connects land squares diagonally across water, but
        #water squares are not passable diagonally across land
        self.segStack = list()
        self.size = 0
        matchValue = matchFunction(x,y)
        #place seed on stack for both directions
        seg = LineSegment(y,x,x,1)
        self.segStack.append(seg) 
        seg = LineSegment(y+1,x,x,-1)
        self.segStack.append(seg) 
        while(len(self.segStack) > 0):
            seg = self.segStack.pop()
            self.scanAndFillLine(seg,areaID,matchValue,matchFunction)
##            if (seg.y < 8 and seg.y > 4) or (seg.y < 70 and seg.y > 64):
##            if (areaID == 4
##                PrintPlotMap(hm)
##                self.PrintAreaMap()
        
        return self.size,matchFunction(x,y)
    def scanAndFillLine(self,seg,areaID,matchValue,matchFunction):
        #check for y + dy being off map
        i = self.getIndex(seg.xLeft,seg.y + seg.dy)
        if i < 0:
##            print "scanLine off map ignoring",str(seg)
            return
        debugReport = False
##        if (seg.y < 8 and seg.y > 4) or (seg.y < 70 and seg.y > 64):
##        if (areaID == 4):
##            debugReport = True
        #for land tiles we must look one past the x extents to include
        #8-connected neighbors
        if self.b8connected:
            if self.bSwitch4Or8OnFalseMatch and matchValue:
                landOffset = 0
            else:
                landOffset = 1
        else:
            if self.bSwitch4Or8OnFalseMatch and matchValue:
                landOffset = 1
            else:
                landOffset = 0
        
        lineFound = False
        #first scan and fill any left overhang
        if debugReport:
            print ""
            print "areaID = %(a)4d" % {"a":areaID}
            print "matchValue = %(w)2d, landOffset = %(l)2d" % {"w":matchValue,"l":landOffset} 
            print str(seg)
            print "Going left"
        if mc.WrapX == True:
            xStop = 0 - (self.mapWidth*20)
        else:
            xStop = -1
        for xLeftExtreme in range(seg.xLeft - landOffset,xStop,-1):
            i = self.getIndex(xLeftExtreme,seg.y + seg.dy)
            if debugReport:
                print "xLeftExtreme = %(xl)4d" % {'xl':xLeftExtreme}
            if debugReport:
                print "i = %d, seg.y + seg.dy = %d" % (i,seg.y + seg.dy)
                print "areaMap[i] = %d, matchValue match = %d" % (self.areaMap[i],matchValue == matchFunction(xLeftExtreme,seg.y + seg.dy))
            if self.areaMap[i] == 0 and matchValue == matchFunction(xLeftExtreme,seg.y + seg.dy):
                self.areaMap[i] = areaID
                self.size += 1
                lineFound = True
            else:
                #if no line was found, then xLeftExtreme is fine, but if
                #a line was found going left, then we need to increment
                #xLeftExtreme to represent the inclusive end of the line
                if lineFound:
                    xLeftExtreme += 1
                break
        if debugReport:
            print "xLeftExtreme finally = %(xl)4d" % {'xl':xLeftExtreme}
            print "Going Right"
        #now scan right to find extreme right, place each found segment on stack
#        xRightExtreme = seg.xLeft - landOffset #needed sometimes? one time it was not initialized before use.
        xRightExtreme = seg.xLeft #needed sometimes? one time it was not initialized before use.
        if mc.WrapX == True:
            xStop = self.mapWidth*20
        else:
            xStop = self.mapWidth
        for xRightExtreme in range(seg.xLeft + lineFound - landOffset,xStop,1):
            if debugReport:            
                print "xRightExtreme = %(xr)4d" % {'xr':xRightExtreme}
            i = self.getIndex(xRightExtreme,seg.y + seg.dy)
            if debugReport:
                print "i = %d, seg.y + seg.dy = %d" % (i,seg.y + seg.dy)
                print "areaMap[i] = %d, matchValue match = %d" % (self.areaMap[i],matchValue == matchFunction(xRightExtreme,seg.y + seg.dy))
            if self.areaMap[i] == 0 and matchValue == matchFunction(xRightExtreme,seg.y + seg.dy):
                self.areaMap[i] = areaID
                self.size += 1
                if lineFound == False:
                    lineFound = True
                    xLeftExtreme = xRightExtreme #starting new line
                    if debugReport:
                        print "starting new line at xLeftExtreme= %(xl)4d" % {'xl':xLeftExtreme}
            elif lineFound == True: #found the right end of a line segment!                
                lineFound = False
                #put same direction on stack
                newSeg = LineSegment(seg.y + seg.dy,xLeftExtreme,xRightExtreme - 1,seg.dy)
                self.segStack.append(newSeg)
                if debugReport:
                    print "same direction to stack",str(newSeg)
                #determine if we must put reverse direction on stack
                if xLeftExtreme < seg.xLeft or xRightExtreme >= seg.xRight:
                    #out of shadow so put reverse direction on stack also
                    newSeg = LineSegment(seg.y + seg.dy,xLeftExtreme,xRightExtreme - 1,-seg.dy)
                    self.segStack.append(newSeg)
                    if debugReport:
                        print "opposite direction to stack",str(newSeg)
                if xRightExtreme >= seg.xRight + landOffset:
                    if debugReport:
                        print "finished with line"
                    break; #past the end of the parent line and this line ends
            elif lineFound == False and xRightExtreme >= seg.xRight + landOffset:
                if debugReport:
                    print "no additional lines found"
                break; #past the end of the parent line and no line found
            else:
                continue #keep looking for more line segments
        if lineFound == True: #still a line needing to be put on stack
            if debugReport:
                print "still needing to stack some segs"
            lineFound = False
            #put same direction on stack
            newSeg = LineSegment(seg.y + seg.dy,xLeftExtreme,xRightExtreme - 1,seg.dy)
            self.segStack.append(newSeg)
            if debugReport:
                print str(newSeg)
            #determine if we must put reverse direction on stack
            if xLeftExtreme < seg.xLeft or xRightExtreme - 1 > seg.xRight:
                #out of shadow so put reverse direction on stack also
                newSeg = LineSegment(seg.y + seg.dy,xLeftExtreme,xRightExtreme - 1,-seg.dy)
                self.segStack.append(newSeg)
                if debugReport:
                    print str(newSeg)
        
        return
    #for debugging
    def PrintAreaMap(self):
        
        print "Area Map"
        for y in range(self.mapHeight - 1,-1,-1):
            lineString = ""
            for x in range(self.mapWidth):
                mapLoc = self.areaMap[self.getIndex(x,y)]
                if mapLoc + 34 > 127:
                    mapLoc = 127 - 34
                lineString += chr(mapLoc + 34)
            lineString += "-" + str(y)
            print lineString
        oid = self.getOceanID()
        if oid == None or oid + 34 > 255:
            print "Ocean ID is unknown"
        else:
            print "Ocean ID is %(oid)4d or %(c)s" % {'oid':oid,'c':chr(oid + 34)}
        lineString = " "
        print lineString

        return
    def PrintList(self,s):
        for a in s:
            char = chr(a.ID + 34)
            lineString = str(a) + ' ' + char
            print lineString
            
class LineSegment :
    def __init__(self,y,xLeft,xRight,dy):
        self.y = y
        self.xLeft = xLeft
        self.xRight = xRight
        self.dy = dy
    def __str__ (self):
        string = "y = %(y)3d, xLeft = %(xl)3d, xRight = %(xr)3d, dy = %(dy)2d" % \
        {'y':self.y,'xl':self.xLeft,'xr':self.xRight,'dy':self.dy}
        return string
                       
class Area :
    def __init__(self,iD,size,water):
        self.ID = iD
        self.size = size
        self.water = water

    def __str__(self):
        string = "{ID = %(i)4d, size = %(s)4d, water = %(w)1d}" % \
        {'i':self.ID,'s':self.size,'w':self.water}
        return string
class AreaPlot :
    def __init__(self,x,y):
        self.x = x
        self.y = y
        self.avgDistance = -1
                    
class BonusPlacer :
    def __init__(self):
        return
    def AddBonuses(self):
        gc = CyGlobalContext()
        gameMap = CyMap()
        gameMap.recalculateAreas()
        self.AssignBonusAreas()
        numBonuses = gc.getNumBonusInfos()
        for order in range(numBonuses):
            placementList = []
            for i in range(numBonuses):
                bonusInfo = gc.getBonusInfo(self.bonusList[i].eBonus)
                if bonusInfo.getPlacementOrder() == order:
                    for n in range(self.bonusList[i].desiredBonusCount):
                        placementList.append(self.bonusList[i].eBonus)
                        
            #Create a list of map indices and shuffle them
            plotIndexList = []
            for i in range(mc.width*mc.height):
                plotIndexList.append(i)
            plotIndexList = ShuffleList(plotIndexList)
            
            if len(placementList) > 0:
                placementList = ShuffleList(placementList)
                for eBonus in placementList:
                    self.AddBonusType(eBonus,plotIndexList)                        
                

        #now check to see that all resources have been placed at least once, this
        #pass ignoring area rules
        for i in range(numBonuses):
            bonus = self.bonusList[i]
            if bonus.currentBonusCount == 0 and bonus.desiredBonusCount > 0:
                self.AddEmergencyBonus(bonus,False)

        #now check again to see that all resources have been placed at least once,
        #this time ignoring area rules and also class spacing
        for i in range(numBonuses):
            bonus = self.bonusList[i]
            if bonus.currentBonusCount == 0 and bonus.desiredBonusCount > 0:
                self.AddEmergencyBonus(bonus,True)                                       

        #now report resources that simply could not be placed
        for i in range(numBonuses):
            bonus = self.bonusList[i]
            if bonus.currentBonusCount == 0 and bonus.desiredBonusCount > 0:
                bonusInfo = gc.getBonusInfo(bonus.eBonus)
                print "No room at all found for %(bt)s!!!" % {"bt":bonusInfo.getType()} 
        return
    def AddEmergencyBonus(self,bonus,ignoreClass):
        gc = CyGlobalContext()
        gameMap = CyMap()
        featureForest = gc.getInfoTypeForString("FEATURE_FOREST")
        plotIndexList = list()
        for i in range(mc.width*mc.height):
            plotIndexList.append(i)
        plotIndexList = ShuffleList(plotIndexList)
        bonusInfo = gc.getBonusInfo(bonus.eBonus)
        for i in range(len(plotIndexList)):
            index = plotIndexList[i]
            plot = gameMap.plotByIndex(index)
            x = plot.getX()
            y = plot.getY()
            if (ignoreClass and self.PlotCanHaveBonus(plot,bonus.eBonus,False,True)) or \
            self.CanPlaceBonusAt(plot,bonus.eBonus,False,True):
                #temporarily remove any feature
                featureEnum = plot.getFeatureType()
                if featureEnum == featureForest:
                    featureVariety = plot.getFeatureVariety()
                    plot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                #place bonus
                plot.setBonusType(bonus.eBonus)
                bonus.currentBonusCount += 1
                #restore the feature if possible
                if featureEnum == featureForest:
                    if bonusInfo == None or bonusInfo.isFeature(featureEnum):
                        plot.setFeatureType(featureEnum,featureVariety)
                print "Emergency placement of 1 %(bt)s" % {"bt":bonusInfo.getType()} 
                break
         
        return
    def AddBonusType(self,eBonus,plotIndexList):
        gc = CyGlobalContext()
        gameMap = CyMap()
        featureForest = gc.getInfoTypeForString("FEATURE_FOREST")
        #first get bonus/area link
        for i in range(gc.getNumBonusInfos()):
            if self.bonusList[i].eBonus == eBonus:
                bonus = self.bonusList[i]
        bonusInfo = gc.getBonusInfo(eBonus)
        
        if bonus.currentBonusCount >= bonus.desiredBonusCount:
            return False

        bonusPlaced = False
        #now add bonuses
        for i in range(len(plotIndexList)):
            index = plotIndexList[i]
            plot = gameMap.plotByIndex(index)
            x = plot.getX()
            y = plot.getY()
            if self.CanPlaceBonusAt(plot,eBonus,False,False):
                #temporarily remove any feature
                featureEnum = plot.getFeatureType()
                if featureEnum == featureForest:
                    featureVariety = plot.getFeatureVariety()
                    plot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                #place bonus
                plot.setBonusType(eBonus)
                bonusPlaced = True
                bonus.currentBonusCount += 1
                #restore the feature if possible
                if featureEnum == featureForest:
                    if bonusInfo == None or bonusInfo.isFeature(featureEnum) or (bonusInfo.getTechReveal() != TechTypes.NO_TECH):
                        plot.setFeatureType(featureEnum,featureVariety)
                groupRange = bonusInfo.getGroupRange()
                for dx in range(-groupRange,groupRange + 1):
                    for dy in range(-groupRange,groupRange + 1):
                        if bonus.currentBonusCount < bonus.desiredBonusCount:
                            loopPlot = self.plotXY(x,y,dx,dy)
                            if loopPlot != None:
                                if loopPlot.getX() == -1:
                                    raise ValueError, "plotXY returns invalid plots plot= %(x)d, %(y)d" % {"x":x,"y":y}
                                if self.CanPlaceBonusAt(loopPlot,eBonus,False,False):
                                    if PRand.randint(0,99) < bonusInfo.getGroupRand():
                                        #temporarily remove any feature
                                        featureEnum = loopPlot.getFeatureType()
                                        if featureEnum == featureForest:
                                            featureVariety = loopPlot.getFeatureVariety()
                                            loopPlot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                                        #place bonus
                                        loopPlot.setBonusType(eBonus)
                                        bonus.currentBonusCount += 1
                                        #restore the feature if possible
                                        if featureEnum == featureForest:
                                            if bonusInfo == None or bonusInfo.isFeature(featureEnum) or (bonusInfo.getTechReveal() != TechTypes.NO_TECH):
                                                loopPlot.setFeatureType(featureEnum,featureVariety)
            if bonusPlaced:
                break
        return bonusPlaced
    
    def plotXY(self,x,y,dx,dy):
        gameMap = CyMap()
        #The one that civ uses will return junk so I have to make one
        #that will not
        x = (x + dx) % mc.width
        y = y + dy
        if y < 0 or y > mc.height - 1:
            return None
        return gameMap.plot(x,y)
        
    def AssignBonusAreas(self):
        gc = CyGlobalContext()
        self.areas = CvMapGeneratorUtil.getAreas()
        gameMap = CyMap()
        self.bonusList = list()
        #Create and shuffle the bonus list and keep tally on
        #one-area bonuses and find the smallest min area requirement
        #among those
        numUniqueBonuses = 0
        minLandAreaSize = -1
        for i in range(gc.getNumBonusInfos()):
            bonus = BonusArea()
            bonus.eBonus = i
            self.bonusList.append(bonus)
            bonusInfo = gc.getBonusInfo(i)
            if bonusInfo.isOneArea() == True:
                numUniqueBonuses += 1
                minAreaSize = bonusInfo.getMinAreaSize()
                if (minLandAreaSize == -1 or minLandAreaSize > minAreaSize) and \
                minAreaSize > 0:
                    minLandAreaSize = minAreaSize
        self.bonusList = ShuffleList(self.bonusList)
        numBonuses = gc.getNumBonusInfos()
        for i in range(numBonuses):
            self.bonusList[i].desiredBonusCount = self.CalculateNumBonusesToAdd(self.bonusList[i].eBonus)
            bonusInfo = gc.getBonusInfo(self.bonusList[i].eBonus)
            eBonus = self.bonusList[i].eBonus
            if bonusInfo.isOneArea() == False:
                continue #Only assign areas to area bonuses
##            print "Trying to find room for %(bt)s, desiredCount=%(dc)d" % {"bt":bonusInfo.getType(),"dc":self.bonusList[i].desiredBonusCount}
            areaSuitabilityList = list()
            for area in self.areas:
                if area.getNumTiles() >= minLandAreaSize:
                    aS = AreaSuitability(area.getID())
                    aS.suitability,aS.numPossible = self.CalculateAreaSuitability(area,eBonus)
                    areaSuitabilityList.append(aS)
##                    print "suitability on areaID=%(aid)d, size=%(s)d is %(r)f" % \
##                    {"aid":area.getID(),"s":area.getNumTiles(),"r":aS.suitability}
            #Calculate how many areas to assign (numUniqueBonuses will be > 0 if we get here)
##            areasPerBonus = (len(areaSuitabilityList)/numUniqueBonuses) + 1
            areasPerBonus =  1
            #Sort areaSuitabilityList best first
            areaSuitabilityList.sort(lambda x,y:cmp(x.numPossible,y.numPossible))
            areaSuitabilityList.reverse()
            #assign the best areas to this bonus
            for n in range(areasPerBonus):
                self.bonusList[i].areaList.append(areaSuitabilityList[n].areaID)
            #assign areas that have a high suitability also
            for n in range(areasPerBonus,len(areaSuitabilityList)):
                if areaSuitabilityList[n].suitability > 0.3:
                    self.bonusList[i].areaList.append(areaSuitabilityList[n].areaID)
        return
    def CanPlaceBonusAt(self,plot,eBonus,bIgnoreLatitude,bIgnoreArea):
        gc = CyGlobalContext()
        gameMap = CyMap()
        x = plot.getX()
        y = plot.getY()
        areaID = plot.getArea()
        if self.PlotCanHaveBonus(plot,eBonus,bIgnoreLatitude,bIgnoreArea) == False:
            return False
        for i in range(DirectionTypes.NUM_DIRECTION_TYPES):
            loopPlot = plotDirection(x,y,DirectionTypes(i))
            if loopPlot.getBonusType(TeamTypes.NO_TEAM) != BonusTypes.NO_BONUS and loopPlot.getBonusType(TeamTypes.NO_TEAM) != eBonus:
               return False

        bonusInfo = gc.getBonusInfo(eBonus)
        classInfo = gc.getBonusClassInfo(bonusInfo.getBonusClassType())
        if plot.isWater() == True:
            if gameMap.getNumBonusesOnLand(eBonus) * 100/(gameMap.getNumBonuses(eBonus) + 1) < bonusInfo.getMinLandPercent():
                return False
        #Make sure there are no bonuses of the same class (but a different type) nearby:
        if classInfo != None:
            try:
                iRange = classInfo.getUniqueRange()
            except:
                iRange = classInfo.getUniqueRange #<--attribute for vanilla
                
            iRange = max(0,int(iRange - (round(mc.BonusBonus) - 1)))
            
            for dx in range(-iRange,iRange+1):
                for dy in range(-iRange,iRange+1):
                    loopPlot = self.plotXY(x,y,dx,dy)
                    if loopPlot != None:
                        if areaID == loopPlot.getArea():
                            if plotDistance(x, y, loopPlot.getX(), loopPlot.getY()) <= iRange:
                                eOtherBonus = loopPlot.getBonusType(TeamTypes.NO_TEAM)
                                if eOtherBonus != BonusTypes.NO_BONUS:
                                    if gc.getBonusInfo(eOtherBonus).getBonusClassType() == bonusInfo.getBonusClassType():
                                        return False
        #Make sure there are no bonuses of the same type nearby:
        iRange = bonusInfo.getUniqueRange()
        iRange = max(0,int(iRange - (round(mc.BonusBonus) - 1)))
        for dx in range(-iRange,iRange+1):
            for dy in range(-iRange,iRange+1):
                loopPlot = self.plotXY(x,y,dx,dy)
                if loopPlot != None:
                    if areaID == loopPlot.getArea():
                        if plotDistance(x, y, loopPlot.getX(), loopPlot.getY()) <= iRange:
                            eOtherBonus = loopPlot.getBonusType(TeamTypes.NO_TEAM)
                            if eOtherBonus != BonusTypes.NO_BONUS:
                                if eOtherBonus == eBonus:
                                    return False
                           
                    
        return True
    def PlotCanHaveBonus(self,plot,eBonus,bIgnoreLatitude,bIgnoreArea):
        #This function is like CvPlot::canHaveBonus but will
        #ignore blocking features and checks for a valid area. 
        gc = CyGlobalContext()
        featureForest = gc.getInfoTypeForString("FEATURE_FOREST")
        if eBonus == BonusTypes.NO_BONUS:
            return True
        if plot.getBonusType(TeamTypes.NO_TEAM) != BonusTypes.NO_BONUS:
            return False
        if plot.isPeak() == True:
            return False
        bonusInfo = gc.getBonusInfo(eBonus)
        #Here is the change from canHaveBonus. Forest does not block bonus
        requiresForest = bonusInfo.isFeature(featureForest)
        plotIsForest = plot.getFeatureType() == featureForest
        #To avoid silk and spices on ice/tundra
        if plotIsForest and requiresForest:
            if bonusInfo.isFeatureTerrain(plot.getTerrainType()) == False:
                return False
        #now that bonuses that require forest are dealt with, count forest
        #as no feature
        else:
            if plot.getFeatureType() != FeatureTypes.NO_FEATURE and not plotIsForest:
                if bonusInfo.isFeature(plot.getFeatureType()) == False:
                    return False           
                if bonusInfo.isFeatureTerrain(plot.getTerrainType()) == False:
                    return False              
            else:
                if bonusInfo.isTerrain(plot.getTerrainType()) == False:
                    return False
                
        if plot.isHills() == True:
            if bonusInfo.isHills() == False:
                return False
        if plot.isFlatlands() == True:
            if bonusInfo.isFlatlands() == False:
                return False
        if bonusInfo.isNoRiverSide() == True:
            if plot.isRiverSide() == True:
                return False
        if bonusInfo.getMinAreaSize() != -1:
            if plot.area().getNumTiles() < bonusInfo.getMinAreaSize():
                return False
        if bIgnoreLatitude == False:
            if plot.getLatitude() > bonusInfo.getMaxLatitude():
                return False
            if plot.getLatitude() < bonusInfo.getMinLatitude():
                return False
        if plot.isPotentialCityWork() == False:
            return False
        
        if bIgnoreArea == False and bonusInfo.isOneArea() == True:
            areaID = plot.getArea()
            areaFound = False
            for i in range(len(self.bonusList)):
                if self.bonusList[i].eBonus == eBonus:
                    areaList = self.bonusList[i].areaList
                    for n in range(len(areaList)):
                        if areaList[n] == areaID:
                            areaFound = True
                            break
                    if areaFound == True:
                        break
            if areaFound == False:
                return False
                        
        return True
    def CalculateNumBonusesToAdd(self,eBonus):
        #This is like the function in CvMapGenerator except it uses
        #self.PlotCanHaveBonus instead of CvPlot::canHaveBonus
        gc = CyGlobalContext()
        gameMap = CyMap()
        game = CyGame()
        bonusInfo = gc.getBonusInfo(eBonus)
        rand1 = PRand.randint(0,bonusInfo.getRandAppearance1())
        rand2 = PRand.randint(0,bonusInfo.getRandAppearance2())
        rand3 = PRand.randint(0,bonusInfo.getRandAppearance3())
        rand4 = PRand.randint(0,bonusInfo.getRandAppearance4())
        baseCount = bonusInfo.getConstAppearance() + rand1 + rand2 + rand3 + rand4

        bIgnoreLatitude = False
        bIgnoreArea = True
        landTiles = 0
        numPossible = 0
        if bonusInfo.getTilesPer() > 0:
            for i in range(mc.width*mc.height):
                plot = gameMap.plotByIndex(i)
                if self.PlotCanHaveBonus(plot,eBonus,bIgnoreLatitude,bIgnoreArea):
                    numPossible += 1
            landTiles += numPossible/bonusInfo.getTilesPer()
        players = game.countCivPlayersAlive() * bonusInfo.getPercentPerPlayer()/100
        bonusCount = baseCount * (landTiles + players)/100
        bonusCount = max(1,int(bonusCount * mc.BonusBonus))
##        print "Calculating bonus amount for %(bt)s" % {"bt":bonusInfo.getType()}
##        print "baseCount=%(bc)d, numPossible=%(np)d, landTiles=%(lt)d, players=%(p)d" % \
##        {"bc":baseCount,"np":numPossible,"lt":landTiles,"p":players}
##        print ""
        return bonusCount
    
    def GetUniqueBonusTypeCountInArea(self,area):
        gc = CyGlobalContext()
        areaID = area.getID()
        uniqueBonusCount = 0
        for i in range(len(self.bonusList)):
            areaList = self.bonusList[i].areaList
            bonusInfo = gc.getBonusInfo(self.bonusList[i].eBonus)
            if bonusInfo.isOneArea() == False:
                continue
            for n in range(len(areaList)):
                if areaList[n] == areaID:
                    uniqueBonusCount += 1
                    break

        return uniqueBonusCount 
    
    def GetSameClassTypeCountInArea(self,area,eBonus):
        gc = CyGlobalContext()
        areaID = area.getID()
        uniqueBonusCount = 0
        bonusInfo = gc.getBonusInfo(eBonus)
        eClass = bonusInfo.getBonusClassType()
        if eClass == BonusClassTypes.NO_BONUSCLASS:
            return 0
        classInfo = gc.getBonusClassInfo(eClass)
        if classInfo == None:
            return 0

        try:
            uRange = classInfo.getUniqueRange()
        except:
            uRange = classInfo.getUniqueRange #<--vanilla Civ4

        uRange = max(0,int(uRange - (round(mc.BonusBonus) - 1)))
                        
        for i in range(len(self.bonusList)):
            areaList = self.bonusList[i].areaList
            bonusInfo = gc.getBonusInfo(self.bonusList[i].eBonus)
            if bonusInfo.isOneArea() == False:
                continue
            if bonusInfo.getBonusClassType() != eClass:
                continue
            for n in range(len(areaList)):
                if areaList[n] == areaID:
                    uniqueBonusCount += 1
                    break
        #Same class types tend to really crowd out any bonus
        #types that are placed later. A single cow can block
        #5 * 5 squares of pig territory for example. Probably
        #shouldn't place them on the same area at all, but
        #sometimes it might be necessary.
        return uniqueBonusCount * uRange * uRange
   
    def CalculateAreaSuitability(self,area,eBonus):
        gc = CyGlobalContext()
        gameMap = CyMap()
        areaID = area.getID()
        uniqueTypesInArea = self.GetUniqueBonusTypeCountInArea(area)
        sameClassTypesInArea = self.GetSameClassTypeCountInArea(area,eBonus)
        #Get the raw number of suitable tiles
        numPossible = 0
        for i in range(mc.width*mc.height):
            plot = gameMap.plotByIndex(i)
            if plot.getArea() == areaID:
                if self.PlotCanHaveBonus(plot,eBonus,False,True):
                    numPossible += 1
        numPossible = numPossible/(uniqueTypesInArea + sameClassTypesInArea + 1)
        suitability = float(numPossible)/float(area.getNumTiles())
        return suitability,numPossible
#Global Access
bp = BonusPlacer()

class BonusArea :
    def __init__(self):
        self.eBonus = -1
        self.desiredBonusCount = -1
        self.currentBonusCount = 0
        self.areaList = list()
            
class AreaSuitability :
    def __init__(self,areaID):
        self.areaID = areaID
        self.suitability = 0
        self.numPossible = 0
        
class StartingPlotFinder :
    def __init__(self):
        return
    def SetStartingPlots(self):
        try:
            gc = CyGlobalContext()
            gameMap = CyMap()
            iPlayers = gc.getGame().countCivPlayersEverAlive()
            gameMap.recalculateAreas()
            areas = CvMapGeneratorUtil.getAreas()

            #get old/new world status
            areaOldWorld = self.setupOldWorldAreaList()
            
            print "len(areaOldWorld) = %d" % len(areaOldWorld)
            
            #Shuffle players so the same player doesn't always get the first pick.
            #lifted from Highlands.py that ships with Civ.
            player_list = []
            for plrCheckLoop in range(gc.getMAX_CIV_PLAYERS()):
                    if CyGlobalContext().getPlayer(plrCheckLoop).isEverAlive():
                            player_list.append(plrCheckLoop)
            shuffledPlayers = []
            for playerLoop in range(iPlayers):
                    iChoosePlayer = PRand.randint(0,len(player_list)-1)
                    shuffledPlayers.append(player_list[iChoosePlayer])
                    del player_list[iChoosePlayer]

            self.startingAreaList = list()
            for i in range(len(areas)):
                if areaOldWorld[i] == True and areas[i].getNumTiles() > 5:
                    startArea = StartingArea(areas[i].getID())
                    self.startingAreaList.append(startArea)

            #Get the value of the whole old world
            oldWorldValue = 0
            for i in range(len(self.startingAreaList)):
                oldWorldValue += self.startingAreaList[i].rawValue

            #calulate value per player of old world
            oldWorldValuePerPlayer = oldWorldValue/len(shuffledPlayers)

            #Sort startingAreaList by rawValue
            self.startingAreaList.sort(lambda x, y: cmp(x.rawValue, y.rawValue))

            #Get rid of areas that have less value than oldWorldValuePerPlayer
            #as they are too small to put a player on, however leave at least
            #half as many continents as there are players, just in case the
            #continents are *all* quite small. 
            numAreas = max(1,len(self.startingAreaList) - len(shuffledPlayers)/2)
            for i in range(numAreas):
                if self.startingAreaList[0].rawValue < oldWorldValuePerPlayer * .75:
                    del self.startingAreaList[0]
                else:
                    break #All remaining should be big enough
                
            #Recalculate the value of the whole old world
            oldWorldValue = 0
            for i in range(len(self.startingAreaList)):
                oldWorldValue += self.startingAreaList[i].rawValue

            #Recalulate value per player of old world so we are starting more
            #accurately
            oldWorldValuePerPlayer = oldWorldValue/len(shuffledPlayers)

            #Record the ideal number of players for each continent
            for startingArea in self.startingAreaList:
                startingArea.idealNumberOfPlayers = int(round(float(startingArea.rawValue)/float(oldWorldValuePerPlayer)))
                if len(startingArea.plotList) < startingArea.idealNumberOfPlayers:
                    startingArea.idealNumberOfPlayers = len(startingArea.plotList)

            #Now we want best first
            self.startingAreaList.reverse()
            print "number of starting areas is %(s)3d" % {"s":len(self.startingAreaList)}

            iterations = 0
            while True:
                iterations += 1
                if iterations > 20:
                    raise Exception, "Too many iterations in starting area choosing loop."
                chosenStartingAreas = list()
                playersPlaced = 0
                #add up idealNumbers
                idealNumbers = 0
                for startingArea in self.startingAreaList:
                    idealNumbers += startingArea.idealNumberOfPlayers
                if idealNumbers < len(shuffledPlayers):
                    self.startingAreaList[0].idealNumberOfPlayers += 1
                elif idealNumbers > len(shuffledPlayers):
                    self.startingAreaList[0].idealNumberOfPlayers -= 1

                #Choose areas
                for startingArea in self.startingAreaList:
                    if startingArea.idealNumberOfPlayers + playersPlaced <= len(shuffledPlayers):
                        chosenStartingAreas.append(startingArea)
                        playersPlaced += startingArea.idealNumberOfPlayers
                        
                #add up idealNumbers again
                idealNumbers = 0
                for startingArea in chosenStartingAreas:
                    idealNumbers += startingArea.idealNumberOfPlayers
                if idealNumbers == len(shuffledPlayers):
                    break
                
            for startingArea in chosenStartingAreas:
                for i in range(startingArea.idealNumberOfPlayers):
                    startingArea.playerList.append(shuffledPlayers[0])
                    del shuffledPlayers[0]
                startingArea.FindStartingPlots()
                            
            if len(shuffledPlayers) > 0:
                raise ValueError,"Some players not placed in starting plot finder!"

            #Now set up for normalization
            self.plotList = list()
            for startingArea in self.startingAreaList:
                for i in range(len(startingArea.plotList)):
    ##                print len(startingArea.plotList)
                    self.plotList.append(startingArea.plotList[i])
                    
            #Remove bad features. (Jungle in the case of standard game)
            for i in range(len(self.plotList)):
                if self.plotList[i].vacant == True:
                    continue
                plot = gameMap.plot(self.plotList[i].x,self.plotList[i].y)
                featureInfo = gc.getFeatureInfo(plot.getFeatureType())
                if featureInfo != None:
                    totalYield = 0
                    for y in range(YieldTypes.NUM_YIELD_TYPES):
                        totalYield += featureInfo.getYieldChange(YieldTypes(y))
                    if totalYield <= 0:#bad feature
                        plot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                
                for n in range(DirectionTypes.NUM_DIRECTION_TYPES):
                    loopPlot = plotDirection(self.plotList[i].x,self.plotList[i].y,DirectionTypes(n))
                    if loopPlot == None:
                        continue
                    featureInfo = gc.getFeatureInfo(loopPlot.getFeatureType())
                    if featureInfo != None:
                        totalYield = 0
                        for y in range(YieldTypes.NUM_YIELD_TYPES):
                            totalYield += featureInfo.getYieldChange(YieldTypes(y))
                        if totalYield <= 0:#bad feature
                            loopPlot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                            
            #find the best totalValue
            self.plotList.sort(lambda x,y:cmp(x.totalValue,y.totalValue))
            self.plotList.reverse()
            bestTotalValue = self.plotList[0].totalValue
            print "bestTotalValue = %(b)6d" % {"b":bestTotalValue}
            for i in range(len(self.plotList)):
                if self.plotList[i].vacant == True:
                    continue
                currentTotalValue = self.plotList[i].totalValue
                percentLacking = 1.0 - (float(currentTotalValue)/float(bestTotalValue))
                if percentLacking > 0:
                    bonuses = min(5,int(percentLacking/0.2))
                    print "boosting plot by %(bv)d" % \
                    {"bv":bonuses}
                    self.boostCityPlotValue(self.plotList[i].x,self.plotList[i].y,bonuses)
        except Exception, e:
            errorPopUp("PerfectWorld's starting plot finder has failed due to a rarely occuring bug, and this map likely has unfair starting locations. You may wish to quit this game and generate a new map.")
            raise Exception, e, sys.exc_traceback           
        return
    
    def setupOldWorldAreaList(self):
        gc = CyGlobalContext()
        gameMap = CyMap()
        #get official areas and make corresponding lists that determines old
        #world vs. new and also the pre-settled value.
        areas = CvMapGeneratorUtil.getAreas()
        areaOldWorld = list()

        print "number of map areas = %d" % len(areas)
        for i in range(len(areas)):
            areaOldWorld.append(True)
            
        return areaOldWorld
    def getCityPotentialValue(self,x,y):
        gc = CyGlobalContext()
        gameMap = CyMap()
#        game.gc.getGame()
        totalValue = 0
        totalFood = 0
        plot = gameMap.plot(x,y)
        if plot.isWater() == True:
            return 0,0
        if float(getRadius(x,y))/float(mc.width) < mc.polarIceRadiusPercent:
            return 0,0
        if plot.isImpassable() == True:
            return 0,0
        cityPlotList = list()
        #The StartPlot class has a nifty function to determine
        #salt water vs. fresh
        sPlot = StartPlot(x,y,0)
        for i in range(gc.getNUM_CITY_PLOTS()):
            plot = plotCity(x,y,i)
            food,value = self.getPlotPotentialValue(plot.getX(),plot.getY(),sPlot.isCoast())
            totalFood += food
            cPlot = CityPlot(food,value)
            cityPlotList.append(cPlot)
        usablePlots = totalFood/gc.getFOOD_CONSUMPTION_PER_POPULATION()
        cityPlotList.sort(lambda x,y:cmp(x.value,y.value))
        cityPlotList.reverse()
        #value is obviously limited to available food
        if usablePlots > gc.getNUM_CITY_PLOTS():
            usablePlots = gc.getNUM_CITY_PLOTS()
        for i in range(usablePlots):
            cPlot = cityPlotList[i]
            totalValue += cPlot.value
        #The StartPlot class has a nifty function to determine
        #salt water vs. fresh
        sPlot = StartPlot(x,y,0)
        if sPlot.isCoast() == True:
            totalValue = int(totalValue)
                
        return totalFood,totalValue
    def getPlotPotentialValue(self,x,y,coastalCity):
        gc = CyGlobalContext()
        gameMap = CyMap()
        game = gc.getGame()
        debugOut = False
        value = 0
        commerce = 0
        food = 0
        production = 0
        plot = gameMap.plot(x,y)
        if debugOut: print "Evaluating plot x = %(x)d, y = %(y)d" % {"x":x,"y":y}
        commerce += plot.calculateBestNatureYield(YieldTypes.YIELD_COMMERCE,TeamTypes.NO_TEAM)
        food += plot.calculateBestNatureYield(YieldTypes.YIELD_FOOD,TeamTypes.NO_TEAM)
        production += plot.calculateBestNatureYield(YieldTypes.YIELD_PRODUCTION,TeamTypes.NO_TEAM)
        if debugOut: print "Natural yields. Food=%(f)d, Production=%(p)d, Commerce=%(c)d" % \
        {"f":food,"p":production,"c":commerce}
        #Get best bonus improvement score. Test tachnology era of bonus
        #first, then test each improvement
        bestImp = None
        bonusEnum = plot.getBonusType(TeamTypes.NO_TEAM) 
        bonusInfo = gc.getBonusInfo(bonusEnum)
        if bonusInfo != None and (gc.getTechInfo(bonusInfo.getTechCityTrade()) == None or \
        gc.getTechInfo(bonusInfo.getTechCityTrade()).getEra() <= game.getStartEra()) and \
        (gc.getTechInfo(bonusInfo.getTechReveal()) == None or \
        gc.getTechInfo(bonusInfo.getTechReveal()).getEra() <= game.getStartEra()): 
            if bonusInfo == None:
                if debugOut: print "Bonus Type = None"
            else:
                if debugOut: print "Bonus Type = %(b)s <------------------------------------------------------------" % {"b":bonusInfo.getType()}
            commerce += bonusInfo.getYieldChange(YieldTypes.YIELD_COMMERCE)
            food += bonusInfo.getYieldChange(YieldTypes.YIELD_FOOD)
            production += bonusInfo.getYieldChange(YieldTypes.YIELD_PRODUCTION)
            if debugOut: print "Bonus yields. Food=%(f)d, Production=%(p)d, Commerce=%(c)d" % \
            {"f":food,"p":production,"c":commerce}
        else:
            bonusEnum = -1
            bonusInfo = None
        improvementList = list()
        for n in range(gc.getNumBuildInfos()):
            #Test for improvement validity
            buildInfo = gc.getBuildInfo(n)
            impEnum = buildInfo.getImprovement()
            impInfo = gc.getImprovementInfo(impEnum)
            if impInfo == None:
                continue
            if buildInfo.getTechPrereq() != TechTypes.NO_TECH and gc.getTechInfo(buildInfo.getTechPrereq()).getEra() > game.getStartEra():
                if debugOut: print "Tech era not high enough for %(s)s" % {"s":impInfo.getType()}
                continue
            else:
                if debugOut: print "Tech is high enough for %(s)s" % {"s":impInfo.getType()}
            if plot.canHaveImprovement(impEnum,TeamTypes.NO_TEAM,True) == True:
                if debugOut: print "Plot can have %(s)s" % {"s":impInfo.getType()}
                #This function will not find bonus yield changes for NO_PLAYER much to my annoyance
                impCommerce = plot.calculateImprovementYieldChange(impEnum,YieldTypes.YIELD_COMMERCE,PlayerTypes.NO_PLAYER,False)
                impFood = plot.calculateImprovementYieldChange(impEnum,YieldTypes.YIELD_FOOD,PlayerTypes.NO_PLAYER,False)
                impProduction = plot.calculateImprovementYieldChange(impEnum,YieldTypes.YIELD_PRODUCTION,PlayerTypes.NO_PLAYER,False)

                if bonusEnum != -1:
                    impCommerce += impInfo.getImprovementBonusYield(bonusEnum,YieldTypes.YIELD_COMMERCE)
                    impFood += impInfo.getImprovementBonusYield(bonusEnum,YieldTypes.YIELD_FOOD)
                    impProduction += impInfo.getImprovementBonusYield(bonusEnum,YieldTypes.YIELD_PRODUCTION)
                #See if feature is removed, if so we must subtract the added yield
                #from that feature
                featureEnum = plot.getFeatureType()
                if featureEnum != -1 and buildInfo.isFeatureRemove(featureEnum) == True:
                    featureInfo = gc.getFeatureInfo(featureEnum)
                    if debugOut: print "Removing feature %(s)s" % {"s":featureInfo.getType()}
                    impCommerce -= (featureInfo.getYieldChange(YieldTypes.YIELD_COMMERCE) + \
                    featureInfo.getRiverYieldChange(YieldTypes.YIELD_COMMERCE) + \
                    featureInfo.getHillsYieldChange(YieldTypes.YIELD_COMMERCE))
                    
                    impFood -= (featureInfo.getYieldChange(YieldTypes.YIELD_FOOD) + \
                    featureInfo.getRiverYieldChange(YieldTypes.YIELD_FOOD) + \
                    featureInfo.getHillsYieldChange(YieldTypes.YIELD_FOOD))
                    
                    impProduction -= (featureInfo.getYieldChange(YieldTypes.YIELD_PRODUCTION) + \
                    featureInfo.getRiverYieldChange(YieldTypes.YIELD_PRODUCTION) + \
                    featureInfo.getHillsYieldChange(YieldTypes.YIELD_PRODUCTION))
                
                imp = Improvement(impEnum,impFood,impProduction,impCommerce,0)
                improvementList.append(imp)
                if debugOut: print "Improv yields. Food=%(f)d, Production=%(p)d, Commerce=%(c)d" % \
                {"f":impFood,"p":impProduction,"c":impCommerce}
            else:
                if debugOut: print "Plot can not have %(s)s" % {"s":impInfo.getType()}
                            
        for i in range(len(improvementList)):
            impCommerce = improvementList[i].commerce + commerce
            impFood = improvementList[i].food + food
            impProduction = improvementList[i].production + production
            impValue = impCommerce * mc.CommerceValue + impFood * mc.FoodValue + impProduction * mc.ProductionValue
            #Food surplus makes the square much more valueable than if there
            #is no food here.
            if food >= gc.getFOOD_CONSUMPTION_PER_POPULATION():
                impValue *= 4
            elif food == gc.getFOOD_CONSUMPTION_PER_POPULATION() - 1:
                impValue *= 2
            improvementList[i].value = impValue
        if len(improvementList) > 0:
            #sort all allowed improvement values to find the best
            improvementList.sort(lambda x,y:cmp(x.value,y.value))
            improvementList.reverse()
            bestImp = improvementList[0]
            if debugOut: print "bestImp.value=%(b)d" % {"b":bestImp.value}    
            commerce += bestImp.commerce
            food += bestImp.food
            production += bestImp.production
        else:
            if debugOut: print "no improvement possible here"
        value = commerce * mc.CommerceValue + food * mc.FoodValue + production * mc.ProductionValue
        if debugOut: print "Evaluating. Food=%(f)d, Production=%(p)d, Commerce=%(c)d" % \
        {"f":food,"p":production,"c":commerce}
        #Cheating to simulate a lighthouse
##        if coastalCity and plot.isWater():
##            food += 1
        #Food surplus makes the square much more valueable than if there
        #is no food here.
        if food >= gc.getFOOD_CONSUMPTION_PER_POPULATION():
            value *= 4
        elif food == gc.getFOOD_CONSUMPTION_PER_POPULATION() - 1:
            value *= 2
        if food + commerce + production < 3:
            value = 0
        if debugOut: print "Final Value = %(v)d" % {"v":value}
        if debugOut: print "****************************************************************"
            
        return food,value
    def boostCityPlotValue(self,x,y,bonuses):
        mapGen = CyMapGenerator()
        food,value = self.getCityPotentialValue(x,y)
        debugOut = False
        if debugOut: print "Value before boost = %(v)d" % {"v":value}
        gc = CyGlobalContext()
        gameMap = CyMap()
        game = gc.getGame()
        #Shuffle the bonus order so that different cities have different preferences
        #for bonuses
        bonusList = list()
        numBonuses = gc.getNumBonusInfos()
        for i in range(numBonuses):
            bonusList.append(i)
        shuffledBonuses = list()
        for i in range(numBonuses):
            n = PRand.randint(0,len(bonusList) - 1)
            shuffledBonuses.append(bonusList[n])
            del bonusList[n]

        if len(shuffledBonuses) != numBonuses:
            raise ValueError, "Bad bonus shuffle. Learn 2 shuffle."

        bonusCount = 0
        
        #Do this process in 3 passes for each non-food yield type, randomly deciding
        #the order of the 3 types
        yields = []
        randomNum = PRand.randint(0,2)
        if randomNum == 0:
            yields.append(YieldTypes.YIELD_PRODUCTION)
            yields.append(YieldTypes.YIELD_FOOD)
            yields.append(YieldTypes.YIELD_COMMERCE)
        elif randomNum == 1:
            yields.append(YieldTypes.YIELD_COMMERCE)
            yields.append(YieldTypes.YIELD_FOOD)
            yields.append(YieldTypes.YIELD_PRODUCTION)
        else:
            yields.append(YieldTypes.YIELD_FOOD)
            yields.append(YieldTypes.YIELD_COMMERCE)
            yields.append(YieldTypes.YIELD_PRODUCTION)
        for n in range(len(yields)):
            for i in range(gc.getNUM_CITY_PLOTS()):
                food,value = self.getCityPotentialValue(x,y)
                
                #switch to food if food is needed
                usablePlots = food/gc.getFOOD_CONSUMPTION_PER_POPULATION()
                if usablePlots <= bonusCount:
                    yields[n] = YieldTypes.YIELD_FOOD
                    
                if debugOut: print "value now at %(v)d" % {"v":value}
                if bonusCount >= bonuses:
                    if debugOut: print "Placed all bonuses."
                    if debugOut: print "****************************************************"
                    return
                plot = plotCity(x,y,i)
                if plot.getX() == x and plot.getY() == y:
                    continue
                if plot.getBonusType(TeamTypes.NO_TEAM) != BonusTypes.NO_BONUS:
                    continue
                #temporarily remove any feature
                featureEnum = plot.getFeatureType()
                if featureEnum != FeatureTypes.NO_FEATURE:
                    featureVariety = plot.getFeatureVariety()
                    plot.setFeatureType(FeatureTypes.NO_FEATURE,-1)
                for b in range(gc.getNumBonusInfos()):
                    bonusEnum = shuffledBonuses[b]
                    bonusInfo = gc.getBonusInfo(bonusEnum)
                    if bonusInfo.isNormalize() == False:
                        continue
                    if bonusInfo.getYieldChange(yields[n]) < 1:
                        continue
                    if bonusInfo.getTechCityTrade() == TechTypes.NO_TECH or \
                    gc.getTechInfo(bonusInfo.getTechCityTrade()).getEra() <= game.getStartEra():
                        if bp.PlotCanHaveBonus(plot,bonusEnum,False,False) == False:
                            if debugOut: print "Plot can't have %(b)s" % {"b":bonusInfo.getType()}
                            continue
                        if debugOut: print "Setting bonus type at %(x)d,%(y)d to %(b)s" % \
                        {"x":plot.getX(),"y":plot.getY(),"b":bonusInfo.getType()}
                        plot.setBonusType(bonusEnum)
                        bonusCount += 1
                        break
                #restore the feature if possible
                if featureEnum != FeatureTypes.NO_FEATURE:
                    bonusInfo = gc.getBonusInfo(plot.getBonusType(TeamTypes.NO_TEAM))
                    if bonusInfo == None or bonusInfo.isFeature(featureEnum):
                        plot.setFeatureType(featureEnum,featureVariety)
                        
                                                
        if debugOut: print "Failed to boost city value. value= %(v)d" % {"v":value}
        if debugOut: print "****************************************************"
        return
#Global access
spf = StartingPlotFinder()
class CityPlot :
    def __init__(self,food,value):
        self.food = food
        self.value = value
class Improvement :
    def __init__(self,e,food,production,commerce,value):
        self.e = e
        self.food = food
        self.production = production
        self.commerce = commerce
        self.value = value

class StartingArea :
    def __init__(self,areaID):
        self.areaID = areaID
        self.playerList = list()
        self.plotList = list()
        self.distanceTable = array('i')
        self.rawValue = 0
        self.CalculatePlotList()
        self.idealNumberOfPlayers = 0
        return
    def CalculatePlotList(self):
        gc = CyGlobalContext()
        gameMap = CyMap()
        
        for y in range(mc.height):
            for x in range(mc.width):
                plot = gameMap.plot(x,y)
                if plot.getArea() == self.areaID:
                    #don't place a city on top of a bonus
                    if plot.getBonusType(TeamTypes.NO_TEAM) != BonusTypes.NO_BONUS:
                        continue
                    food,value = spf.getCityPotentialValue(x,y)
                    if value > 0:
                        startPlot = StartPlot(x,y,value)
                        if plot.isWater() == True:
                            raise ValueError, "potential start plot is water!"
                        self.plotList.append(startPlot)
        #Sort plots by local value
        self.plotList.sort(lambda x, y: cmp(x.localValue, y.localValue))
        
        #To save time and space let's get rid of some of the lesser plots
        cull = (len(self.plotList) * 2) / 3
        for i in range(cull):
            del self.plotList[0]
            
        #You now should be able to eliminate more plots by sorting high to low
        #and having the best plot eat plots within 3 squares, then same for next,
        #etc.
        self.plotList.reverse()
##        print "number of initial plots in areaID = %(a)3d is %(p)5d" % {"a":self.areaID,"p":len(self.plotList)}
        numPlots = len(self.plotList)
        for n in range(numPlots):
            #At some point the length of plot list will be much shorter than at
            #the beginning of the loop, so it can never end normally
            if n >= len(self.plotList) - 1:
                break
            y = self.plotList[n].y
            x = self.plotList[n].x
            for yy in range(y - 3,y + 4):
                for xx in range(x - 3,x + 4):
                    if yy < 0 or yy >= mc.height:
                        continue
                    xx = xx % mc.width#wrap xx
                    if xx < 0:
                        raise ValueError, "xx value not wrapping properly in StartingArea.CalculatePlotList"
                    for m in range(n,len(self.plotList)):
                        #At some point the length of plot list will be much shorter than at
                        #the beginning of the loop, so it can never end normally
                        if m >= len(self.plotList) - 1:
                            break
##                        print "m = %(m)3d, n = %(n)3d" % {"m":m,"n":n}
                        if self.plotList[m] != self.plotList[n]:
                            if self.plotList[m].x == xx and self.plotList[m].y == yy:
##                                print "deleting m = %(m)3d" % {"m":m}
                                del self.plotList[m]
##                                print "length of plotList now %(len)4d" % {"len":len(self.plotList)}
                                 
##        print "number of final plots in areaID = %(a)3d is %(p)5d" % {"a":self.areaID,"p":len(self.plotList)}
                                
        #At this point we should have a list of the very best places
        #to build cities on this continent. Now we need a table with
        #the distance from each city to every other city

        #Create distance table
        for i in range(len(self.plotList)*len(self.plotList)):
            self.distanceTable.append(-11)
        #Fill distance table
        for n in range(len(self.plotList)):
            #While were already looping lets calculate the raw value
            self.rawValue += self.plotList[n].localValue
            avgDistance = 0
            for m in range(n,len(self.plotList)):
                nPlot = gameMap.plot(self.plotList[n].x,self.plotList[n].y)
                mPlot = gameMap.plot(self.plotList[m].x,self.plotList[m].y)
                gameMap.resetPathDistance()
                distance = gameMap.calculatePathDistance(nPlot,mPlot)
#               distance = self.getDistance(nPlot.getX(),nPlot.getY(),mPlot.getX(),mPlot.getY())
                #If path fails try reversing it
##                gameMap.resetPathDistance()
##                newDistance = gameMap.calculatePathDistance(mPlot,nPlot)
##                if distance != newDistance:
##                    print "distance between n=%(n)d nx=%(nx)d,ny=%(ny)d and m=%(m)d mx=%(mx)d,my=%(my)d is %(d)d or %(nd)d" % \
##                    {"n":n,"nx":nPlot.getX(),"ny":nPlot.getY(),"m":m,"mx":mPlot.getX(),"my":mPlot.getY(),"d":distance,"nd":newDistance}
                self.distanceTable[n*len(self.plotList) + m] = distance
                self.distanceTable[m*len(self.plotList) + n] = distance
                avgDistance += distance
            self.plotList[n].avgDistance = avgDistance
 
        return
    def FindStartingPlots(self):
        gc = CyGlobalContext()
        gameMap = CyMap()
        numPlayers = len(self.playerList)
        if numPlayers <= 0:
            return

        avgDistanceList = list()
        for i in range(len(self.plotList)):
            avgDistanceList.append(self.plotList[i])
            
        #Make sure first guy starts on the end and not in the middle,
        #otherwise if there are two players one will start on the middle
        #and the other on the end
        avgDistanceList.sort(lambda x,y:cmp(x.avgDistance,y.avgDistance))
        avgDistanceList.reverse()
        #First place players as far as possible away from each other
        #Place the first player
        avgDistanceList[0].vacant = False
        for i in range(1,numPlayers):
            distanceList = list()
            for n in range(len(self.plotList)):
                if self.plotList[n].vacant == True:
                    minDistance = -1
                    for m in range(len(self.plotList)):
                        if self.plotList[m].vacant == False:
                            ii = n * len(self.plotList) + m
                            distance = self.distanceTable[ii]
                            if minDistance == -1 or minDistance > distance:
                                minDistance = distance
                    self.plotList[n].nearestStart = minDistance
                    distanceList.append(self.plotList[n])
            #Find biggest nearestStart and place a start there
            distanceList.sort(lambda x,y:cmp(x.nearestStart,y.nearestStart))
            distanceList.reverse()
            distanceList[0].vacant = False
##            print "Placing start at x=%(x)d, y=%(y)d nearestDistance to city is %(n)d" % \
##            {"x":distanceList[0].x,"y":distanceList[0].y,"n":distanceList[0].nearestStart}
                
        self.CalculateStartingPlotValues()
                
##        self.PrintPlotMap()
##        self.PrintPlotList()
##        self.PrintDistanceTable()
      
        #Now place all starting positions
        n = 0
        for m in range(len(self.plotList)):
            if self.plotList[m].vacant == False:
                sPlot = gameMap.plot(self.plotList[m].x,self.plotList[m].y)
                if sPlot.isWater() == True:
                    raise ValueError, "Start plot is water!"
                sPlot.setImprovementType(gc.getInfoTypeForString("NO_IMPROVEMENT"))
                playerID = self.playerList[n]
                player = gc.getPlayer(playerID)
                sPlot.setStartingPlot(True)
                player.setStartingPlot(sPlot,True)
                n += 1

            
        return
    def CalculateStartingPlotValues(self):
        gameMap = CyMap()
        numPlots = len(self.plotList)
        
        for n in range(numPlots):
            self.plotList[n].owner = -1
            self.plotList[n].totalValue = 0
            
        for n in range(numPlots):
            if self.plotList[n].vacant == True:
                continue
            self.plotList[n].totalValue = 0
            self.plotList[n].numberOfOwnedCities = 0
            for m in range(numPlots):
                i = n * numPlots + m
                nDistance = self.distanceTable[i]
                if nDistance == -1:
                    leastDistance = False
                else:
                    leastDistance = True #Being optimistic, prove me wrong
                for p in range(numPlots):
                    if p == n or self.plotList[p].vacant == True:
                        continue
                    ii = p * numPlots + m
                    pDistance = self.distanceTable[ii]
##                    print "n= %(n)3d, m = %(m)3d, p = %(p)3d, nDistance = %(nd)3d, pDistance = %(pd)3d" %\
##                    {"n":n,"m":m,"p":p,"nd":nDistance,"pd":pDistance}
                    if pDistance > -1 and pDistance <= nDistance:
                        leastDistance = False #Proven wrong
                        break
                    
                if leastDistance == True:
                    self.plotList[n].totalValue += self.plotList[m].localValue
#                    print "m = %(m)3d owner change from %(mo)3d to %(n)3d" % {"m":m,"mo":self.plotList[m].owner,"n":n}
                    self.plotList[m].owner = self.plotList[n]
                    self.plotList[m].distanceToOwner = nDistance
                    self.plotList[n].numberOfOwnedCities += 1
                    
        return
    def getDistance(self,x,y,dx,dy):
        xx = x - dx
        if abs(xx) > mc.width/2:
            xx = mc.width - abs(xx)
            
        distance = max(abs(xx),abs(y - dy))
        return distance
    def PrintPlotMap(self):
        gameMap = CyMap()
        print "Starting Plot Map"
        for y in range(hm.mapHeight - 1,-1,-1):
            lineString = ""
            for x in range(hm.mapWidth):
                inList = False
                for n in range(len(self.plotList)):
                    if self.plotList[n].x == x and self.plotList[n].y == y:
                        if self.plotList[n].plot().isWater() == True:
                            if self.plotList[n].vacant == True:
                                lineString += 'VV'
                            else:
                                lineString += 'OO'
                        else:
                            if self.plotList[n].vacant == True:
                                lineString += 'vv'
                            else:
                                lineString += 'oo'
                        inList = True
                        break
                if inList == False:
                    plot = gameMap.plot(x,y)
                    if plot.isWater() == True:
                        lineString += '.;'
                    else:
                        lineString += '[]'

            lineString += "-" + str(y)
            print lineString
            
        lineString = " "
        print lineString

        return
    def PrintPlotList(self):
        for n in range(len(self.plotList)):
            print str(n) + ' ' + str(self.plotList[n])
        return
    
    def PrintDistanceTable(self):
        print "Distance Table"
        lineString = "%(n)05d" % {"n":0} + ' '
        for n in range(len(self.plotList)):
            lineString += "%(n)05d" % {"n":n} + ' '
        print lineString
        lineString = ""
        for n in range(len(self.plotList)):
            lineString = "%(n)05d" % {"n":n} + ' '
            for m in range(len(self.plotList)):
                i = n * len(self.plotList) + m
                lineString += "%(d)05d" % {"d":self.distanceTable[i]} + ' '
            print lineString    
        return

class StartPlot :
    def __init__(self,x,y,localValue):
        self.x = x
        self.y = y
        self.localValue = localValue
        self.totalValue = 0
        self.numberOfOwnedCities = 0
        self.distanceToOwner = -1
        self.nearestStart = -1
        self.vacant = True
        self.owner = None
        self.avgDistance = 0
        return
    def isCoast(self):
        gameMap = CyMap()
        plot = gameMap.plot(self.x,self.y)
        waterArea = plot.waterArea()
        if waterArea.isNone() == True or waterArea.isLake() == True: 
            return False
        return True
    def plot(self):
        gameMap = CyMap()
        return gameMap.plot(self.x,self.y)
    def copy(self):
        cp = StartPlot(self.x,self.y,self.localValue)
        cp.totalValue = self.totalValue
        cp.numberOfOwnedCities = self.numberOfOwnedCities
        cp.distanceToOwner = self.distanceToOwner
        cp.nearestStart = self.nearestStart
        cp.vacant = self.vacant
        cp.owner = self.owner
        cp.avgDistance = self.avgDistance
        return cp
    def __str__(self):
        linestring = "x=%(x)3d,y=%(y)3d,localValue=%(lv)6d,totalValue =%(tv)6d, nearestStart=%(ad)6d, coastalCity=%(cc)d" % \
        {"x":self.x,"y":self.y,"lv":self.localValue,"tv":self.totalValue,"ad":self.nearestStart,"cc":self.isCoast()}
        return linestring
        
hm = HeightMap()
sm = SmallMaps()
###############################################################################     
#functions that civ is looking for
###############################################################################
def getDescription():
	return "A mapscript that seeks to recreate the polar maps drawn by Frank Herbert for the Dune novels. Consists of a Polar area in the center, surrounded by broken rock islands and finally a sea of dunes."
	
def getWrapX():
	return mc.WrapX
	
def getWrapY():
    print "mc.WrapY == %d at getWrapY" % mc.WrapY
    return mc.WrapY
    
def getNumCustomMapOptions():
	"""
	Number of different user-defined options for this map
	Return an integer
	"""
	return 4

def getCustomMapOptionName(argsList):
        """
        Returns name of specified option
        argsList[0] is Option ID (int)
        Return a Unicode string
        """
        optionID = argsList[0]
        if optionID == 0:
            return "Land Percentage"
        elif optionID == 1:
            return "Landmass Style"
        elif optionID == 2:
            return "Landmass Outer Radius"
        elif optionID == 3:
            return "Polar Region Size"
			
        return u""
	
def getNumCustomMapOptionValues(argsList):
        """
        Number of different choices for a particular setting
        argsList[0] is Option ID (int)
        Return an integer
        """
        optionID = argsList[0]
        if optionID == 0:
            return 12
        elif optionID == 1:
            return 4
        elif optionID == 2:
            return 6
        elif optionID == 3:
            return 3					
        return 0
	
def getCustomMapOptionDescAt(argsList):
    """
    Returns name of value of option at specified row
    argsList[0] is Option ID (int)
    argsList[1] is Selection Value ID (int)
    Return a Unicode string
    """
    optionID = argsList[0]
    selectionID = argsList[1]
    if optionID == 0:
        if selectionID == 0:
            return "18%"
        elif selectionID == 1:
            return "20%"
        elif selectionID == 2:
            return "22%"
        elif selectionID == 3:
            return "24% (Default)"
        elif selectionID == 4:
            return "26%"			
        elif selectionID == 5:
            return "28%"				
        elif selectionID == 6:
            return "30%"				
        elif selectionID == 7:
            return "32%"				
        elif selectionID == 8:
            return "34%"				
        elif selectionID == 9:
            return "36%"				
        elif selectionID == 10:
            return "38%"				
        elif selectionID == 11:
            return "40%"
    elif optionID == 1:
        if selectionID == 0:
            return "Islands Style (Default)"
        elif selectionID == 1:
            return "Irregular Islands Style"
        elif selectionID == 2:
            return "Pangaea Style"	
        elif selectionID == 3:
            return "Larger Islands Style"				
    elif optionID == 2:
        if selectionID == 0:
            return "64 degrees"
        elif selectionID == 1:
            return "66 degrees"
        elif selectionID == 2:
            return "68 degrees (Default)"	
        elif selectionID == 3:
            return "70 degrees"
        elif selectionID == 4:
            return "72 degrees"	
        elif selectionID == 5:
            return "74 degrees"		
    elif optionID == 3:
        if selectionID == 0:
            return "Default"
        elif selectionID == 1:
            return "Bigger"
        elif selectionID == 2:
            return "Biggest"			
		
    return u""
	
def getCustomMapOptionDefault(argsList):
    """
    Returns default value of specified option
    argsList[0] is Option ID (int)
    Return an integer
    """
    optionID = argsList[0]
    if optionID == 0:
        return 3
    if optionID == 1:
        return 0   
    if optionID == 2:
        return 2
    if optionID == 3:
        return 0    	
    return 0
    
def isRandomCustomMapOption(argsList):
    """
    Returns a flag indicating whether a random option should be provided
    argsList[0] is Option ID (int)
    Return a bool
    """
    return True
    
#This doesn't work with my river system so it is disabled. Some civs
#might start without a river. Boo hoo.
def normalizeAddRiver():
    return
def normalizeAddLakes():
    return
def normalizeAddGoodTerrain():
    return
def normalizeRemoveBadTerrain():
    return
def normalizeRemoveBadFeatures():
    return
def normalizeAddFoodBonuses():
    return
def normalizeRemovePeaks():
    return
def normalizeAddExtras():
    return
def isAdvancedMap():
	"""
	Advanced maps only show up in the map script pulldown on the advanced menu.
	Return 0 if you want your map to show up in the simple singleplayer menu
	"""
	return 0
def isClimateMap():
	"""
	Uses the Climate options
	"""
	return 0
	
def isSeaLevelMap():
	"""
	Uses the Sea Level options
	"""
	return 0
    
def getTopLatitude():
	"Default is 90. 75 is past the Arctic Circle"
	return 90

def getBottomLatitude():
	"Default is -90. -75 is past the Antartic Circle"
	return -90
    
def getGridSize(argsList):
    mc.initialize()
    mc.initInGameOptions()
    grid_sizes = {
		WorldSizeTypes.WORLDSIZE_DUEL:		(8,8),
		WorldSizeTypes.WORLDSIZE_TINY:		(10,10),
		WorldSizeTypes.WORLDSIZE_SMALL:		(13,13),
		WorldSizeTypes.WORLDSIZE_STANDARD:	(16,16),
		WorldSizeTypes.WORLDSIZE_LARGE:		(18,18),
		WorldSizeTypes.WORLDSIZE_HUGE:		(21,21),
                WorldSizeTypes.NUM_WORLDSIZE_TYPES:     (22,22)
    }
    if (argsList[0] == -1): # (-1,) is passed to function on loads
            return []
    [eWorldSize] = argsList
    return grid_sizes[eWorldSize]

def generatePlotTypes():
    gc = CyGlobalContext()
    mmap = gc.getMap()
    mc.width = mmap.getGridWidth()
    mc.height = mmap.getGridHeight()
    mc.minimumMeteorSize = (1 + int(round(float(mc.hmWidth)/float(mc.width)))) * 3
    PRand.seed()
    hm.generateHeightMap()
    hm.adjustArrakisAltitude()
    hm.calculateSeaLevel()
    hm.makeShieldWall()
    sm.initialize()
    plotTypes = [PlotTypes.PLOT_OCEAN] * (mc.width*mc.height)

    for i in range(mc.width*mc.height):
        mapLoc = sm.plotMap[i]
        if mapLoc == mc.PEAK:
            plotTypes[i] = PlotTypes.PLOT_PEAK
        elif mapLoc == mc.HILLS:
            plotTypes[i] = PlotTypes.PLOT_HILLS
        elif mapLoc == mc.LAND:
            plotTypes[i] = PlotTypes.PLOT_LAND
        else:
            plotTypes[i] = PlotTypes.PLOT_OCEAN
    print "Finished generating plot types."         
    return plotTypes
def generateTerrainTypes():
    NiTextOut("Generating Terrain  ...")
    print "Adding Terrain"
    gc = CyGlobalContext()
    terrainDesert = gc.getInfoTypeForString("TERRAIN_DESERT")
    terrainPlains = gc.getInfoTypeForString("TERRAIN_PLAINS")
    terrainIce = gc.getInfoTypeForString("TERRAIN_SNOW")
    terrainGrass = gc.getInfoTypeForString("TERRAIN_GRASS")
    terrainHill = gc.getInfoTypeForString("TERRAIN_HILL")
    terrainCoast = gc.getInfoTypeForString("TERRAIN_COAST")
    terrainOcean = gc.getInfoTypeForString("TERRAIN_OCEAN")
    terrainPeak = gc.getInfoTypeForString("TERRAIN_PEAK")
    terrainPolar = gc.getInfoTypeForString("TERRAIN_POLAR")
    terrainPolarPlains = gc.getInfoTypeForString("TERRAIN_POLAR_PLAINS")
    terrainPolarCoast = gc.getInfoTypeForString("TERRAIN_POLAR_COAST")
    terrainSalt = gc.getInfoTypeForString("TERRAIN_SALT")
    
    terrainTypes = [0]*(mc.width*mc.height)
    for i in range(mc.width*mc.height):
        if sm.terrainMap[i] == mc.OCEAN:
            terrainTypes[i] = terrainOcean
        elif sm.terrainMap[i] == mc.COAST:
            terrainTypes[i] = terrainCoast
        elif sm.terrainMap[i] == mc.DESERT:
            terrainTypes[i] = terrainDesert
        elif sm.terrainMap[i] == mc.PLAINS:
            terrainTypes[i] = terrainPlains
        elif sm.terrainMap[i] == mc.GRASS:
            terrainTypes[i] = terrainGrass
        elif sm.terrainMap[i] == mc.SNOW:
            terrainTypes[i] = terrainIce
        elif sm.terrainMap[i] == mc.POLAR:
            terrainTypes[i] = terrainPolar
        elif sm.terrainMap[i] == mc.POLAR_COAST:
            terrainTypes[i] = terrainPolarCoast
        elif sm.terrainMap[i] == mc.POLAR_PLAINS:
            terrainTypes[i] = terrainPolarPlains
        elif sm.terrainMap[i] == mc.SALT:
            terrainTypes[i] = terrainSalt
    print "Finished generating terrain types."
    return terrainTypes

def addRivers():
    return
            
def addLakes():
    return
        
def addFeatures():
    CvMapGeneratorUtil.addDuneFeatures()

### davidlallen: starting plots code

class DuneWarsStart:
	# Define some additional variables needed by plot code
	def Init(self):
		self.iBSpice  = gc.getInfoTypeForString("BONUS_SPICE")
		self.iTGrab   = gc.getInfoTypeForString("TERRAIN_PLAINS")
		self.iTOcean  = gc.getInfoTypeForString("TERRAIN_OCEAN")
		self.iTPCoast = gc.getInfoTypeForString("TERRAIN_POLAR_COAST")
		self.iTRock   = gc.getInfoTypeForString("TERRAIN_GRASS")
		self.iTRug    = gc.getInfoTypeForString("TERRAIN_SNOW")
		self.iTSalt   = gc.getInfoTypeForString("TERRAIN_SALT")
		self.iBGround = gc.getInfoTypeForString("BONUS_GROUNDWATER")
		self.iBCrys   = gc.getInfoTypeForString("BONUS_CRYSTAL")
		self.iBNit    = gc.getInfoTypeForString("BONUS_NITRATES")
		self.iBIce    = gc.getInfoTypeForString("BONUS_POLAR_ICE")
		self.iTPolar  = gc.getInfoTypeForString("TERRAIN_POLAR")
		self.iTCoast  = gc.getInfoTypeForString("TERRAIN_COAST")
		self.iTDune   = gc.getInfoTypeForString("TERRAIN_DESERT")
		self.iFArch   = gc.getInfoTypeForString("FEATURE_ROCK_ARCH")
		self.iFArch2  = gc.getInfoTypeForString("FEATURE_ROCK_ARCH2")
		self.iFRock1  = gc.getInfoTypeForString("FEATURE_ROCK_FORM1")
		self.iFRock2  = gc.getInfoTypeForString("FEATURE_ROCK_FORM2")
		self.iFRock3  = gc.getInfoTypeForString("FEATURE_ROCK_FORM3")
		self.iFRock4  = gc.getInfoTypeForString("FEATURE_ROCK_FORM4")
		self.iFPArch  = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_ARCH")
		self.iFPArch2 = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_ARCH2")
		self.iFPRock1 = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_FORM1")
		self.iFPRock2 = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_FORM2")
		self.iFPRock3 = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_FORM3")
		self.iFPRock4 = gc.getInfoTypeForString("FEATURE_POLAR_ROCK_FORM4")
		self.iFDArch  = gc.getInfoTypeForString("FEATURE_DARK_ROCK_ARCH")
		self.iFDArch2 = gc.getInfoTypeForString("FEATURE_DARK_ROCK_ARCH2")
		self.iFDRock1 = gc.getInfoTypeForString("FEATURE_DARK_ROCK_FORM1")
		self.iFDRock2 = gc.getInfoTypeForString("FEATURE_DARK_ROCK_FORM2")
		self.iFDRock3 = gc.getInfoTypeForString("FEATURE_DARK_ROCK_FORM3")
		self.iFDRock4 = gc.getInfoTypeForString("FEATURE_DARK_ROCK_FORM4")
		self.iFPeak1  = gc.getInfoTypeForString("FEATURE_PEAK1")
		self.iFPeak2  = gc.getInfoTypeForString("FEATURE_PEAK2")
		self.iFPeak3  = gc.getInfoTypeForString("FEATURE_PEAK3")
		self.outcropFeaturesArray = [self.iFArch, self.iFArch2, self.iFRock1, self.iFRock2, self.iFRock3, self.iFRock4,self.iFPArch, self.iFPArch2, self.iFPRock1, self.iFPRock2, self.iFPRock3, self.iFPRock4, self.iFDArch, self.iFDArch2, self.iFDRock1, self.iFDRock2, self.iFDRock3, self.iFDRock4]			
		self.peakFeaturesArray = [self.iFPeak1, self.iFPeak2, self.iFPeak3]	
		self.iXmax    = CyMap().getGridWidth()
		self.iYmax    = CyMap().getGridHeight()
		self.dBWater  = {
			gc.getInfoTypeForString("BONUS_SPIKED_PAINTBUSH") : 1,
			gc.getInfoTypeForString("BONUS_CREOSOTE_BUSH") : 1,
			gc.getInfoTypeForString("BONUS_BARREL_CACTUS") : 1,
			gc.getInfoTypeForString("BONUS_SAND_VERBENA") : 1,
			gc.getInfoTypeForString("BONUS_BURRO_WEED") : 1,
			gc.getInfoTypeForString("BONUS_SWORD_GRASS") : 1
		}

	# Compute score for one plot based on resource and terrain
	def Score(self, pPlot):
		# Do not score plots with Peak Features or Outcrops
		iFeature = pPlot.getFeatureType()
		if (iFeature in self.peakFeaturesArray or iFeature in self.outcropFeaturesArray): return 0	
		iBonus = pPlot.getBonusType(TeamTypes.NO_TEAM)
		if iBonus == -1:                   iScore =  0
		elif iBonus == self.iBGround:      iScore = 50
		elif self.dBWater.has_key(iBonus): iScore = 40
		elif iBonus != self.iBSpice:       iScore = 10
		else:                              iScore =  0
		# Terrain
		iTerrain = pPlot.getTerrainType()
		if pPlot.isPeak(): iScore += 30
		elif iTerrain == self.iTPolar:  iScore += 5
		elif iTerrain == self.iTGrab:   iScore += 3
		elif iTerrain == self.iTPCoast: iScore += 3
		elif iTerrain == self.iTRock:   iScore += 2
		elif iTerrain == self.iTCoast:  iScore += 2
		elif iTerrain == self.iTRug:    iScore += 1
		return iScore

	# Determine which pie-shaped sector this plot belongs to
	def Sector(self, iNumCivs, pPlot):
		dx = pPlot.getX() - (self.iXmax / 2)
		dy = pPlot.getY() - (self.iYmax / 2)
		fRads = math.atan2(dx, dy) + math.pi
		iCiv = int (0.5 + (fRads * iNumCivs / (2.0 * math.pi)))
		if iCiv == iNumCivs: iCiv = 0
		return iCiv

	# Determine radial distance from center as an integer percentage
	def RadialDistance(self, pPlot):
		dx = pPlot.getX() - (self.iXmax / 2)
		dy = pPlot.getY() - (self.iYmax / 2)
		dist = math.sqrt ((dx * dx) + (dy * dy))
		return int (200.0 * dist / self.iXmax)

	# Compute the total score for each sector and return sorted list
	# of sectors, lowest score first
	def RankSectors(self):
		# Find the number of alive, non-barbarian civs
		iNumCivs = 0
		for iPlay in range(gc.getMAX_CIV_PLAYERS()):
			pPlay = gc.getPlayer(iPlay)
			if not pPlay.isAlive(): continue
			if pPlay.isBarbarian(): continue
			iNumCivs += 1
		# Count the total score of each sector
		dTotal = {}
		for i in range(iNumCivs): dTotal[i] = 0
		for iPlotLoop in range(CyMap().numPlots()):
			pPlot = CyMap().plotByIndex(iPlotLoop)
			if pPlot.isWater(): continue
			i = self.Sector(iNumCivs, pPlot)
			dTotal[i] += self.Score(pPlot)
		# Build a list of sector numbers, sorted lowest score first
		lSecSco = [] ; lSec = []
		for i in range(iNumCivs):
			lSecSco.append([i, dTotal[i]])
		for lss in sorted(lSecSco, key=operator.itemgetter(1)):
			lSec.append(lss[0])
		return lSec

	# What is the total value of the BFC at this site?
	def BFCValue(self, pPlot):
		cx = pPlot.getX() ; cy = pPlot.getY()
		iScore = 0
		bIce = false ; bNitrates = false ; bCrystal = false
		for dx in range (-2, 3):
			x = cx + dx
			if (x < 0) or (x >= self.iXmax): continue
			for dy in range (-2, 3):
				y = cy + dy
				if (y < 0) or (y >= self.iYmax): continue
				if (dx == 0) and (dy == 0): continue
				if (abs(dx) == 2) and (abs(dy) == 2): continue
				pPlot2 = CyMap().plot(x, y)
				iScore = iScore + self.Score(pPlot2)
				iBonus = pPlot.getBonusType(TeamTypes.NO_TEAM)
				if iBonus == self.iBNit: bNitrates = true
				if iBonus == self.iBCrys: bCrystal = true
				if iBonus == self.iBIce: bIce = true
		if bNitrates: iScore += 100
		if bCrystal: iScore += 100
		if bIce: iScore += 100
		return iScore

	# Return a dictionary on sectors with lists of possible city sites
	def Locations(self, iNumCivs):
		dSites = {}
		for i in range(iNumCivs): dSites[i] = []
		for iPlotLoop in range(CyMap().numPlots()):
			pPlot = CyMap().plotByIndex(iPlotLoop)
			# Some conditions to skip for city sites
			if pPlot.isWater(): continue
			if pPlot.isPeak(): continue
			# Never put a city *on* a bonus
			if pPlot.getBonusType(TeamTypes.NO_TEAM) != -1: continue
			# Do not allow cities on Peak Features or Outcrop
			iFeature = pPlot.getFeatureType()
			if (iFeature in self.peakFeaturesArray or iFeature in self.outcropFeaturesArray): continue	
			# Do not allow starting cities on polar
			iTerrain = pPlot.getTerrainType()
			if iTerrain == self.iTPolar: continue
			# Dunes is a terrible location, so is salt
			if iTerrain == self.iTDune: continue
			if iTerrain == self.iTSalt: continue
			# Don't allow if too close or too far from pole
			iDistPct = self.RadialDistance(pPlot)
			if (iDistPct < 40) or (iDistPct > 80): continue
			# Compute score
			iSector = self.Sector(iNumCivs, pPlot)
			iScore = self.BFCValue(pPlot)
			# Don't bother adding poor locations
			if iScore < 160: continue 
			l = [pPlot.getX(), pPlot.getY(), iScore]
			dSites[iSector].append(l)
		return dSites

	# Using the score - threshold of each site, pick site by weight
	def Pick(self, lSites, iThreshold):
		iTotal = 0 ; lFixed = []
		for lxys in lSites:
			cx, cy, iScore = lxys
			iScore -= iThreshold
			lFixed.append([cx, cy, iScore])
			iTotal += iScore
		iGoal = CyGame().getSorenRandNum(iTotal, "sitepick")
		iTotal = 0
		for lxys in lSites:
			cx, cy, iScore = lxys
			iTotal += iScore
			if iGoal < iTotal: return cx, cy

	# Top level routine to find start locations
	def Find(self):
		lSectors = self.RankSectors()
		iNumCivs = len(lSectors)
		dSites = self.Locations(iNumCivs)
		lThresholds = [240, 240, 220, 220, 200, 200, 180, 180]
		lSeparations = [16, 14, 12, 10, 8, 6]
		lSites = []
		for iSeparation in lSeparations:
			for iThreshold in lThresholds:
				bSuccess = true
				for i in range(iNumCivs):
					iSector = lSectors[i]
					lFarEnough = []
					for lxys in dSites[iSector]:
						cx, cy, iScore = lxys
						if iScore < iThreshold: continue
						# Reject if too close to a chosen site
						bFarEnough = true
						for lxy in lSites:
							sx, sy = lxy
							if (abs(cx - sx) < iSeparation) and (abs(cy - sy) < iSeparation):
								bFarEnough = false
								break
						if bFarEnough:
							lFarEnough.append(lxys)
					iSites = len(lFarEnough)
					if iSites == 0:
						bSuccess = false
						break
					else:
						cx, cy = self.Pick(lFarEnough, iThreshold)
						lSites.append([cx, cy])
				if bSuccess: break
				else:
					# Failed; clean and try again
					lSites = []
			if bSuccess: break
		return lSites

# Assign starting plots.  Also unrelatedly, only allow rock under mesa
gc = CyGlobalContext()
def assignStartingPlots():
	dws = DuneWarsStart()
	dws.Init()
	lSites = ShuffleList(dws.Find())
	gc = CyGlobalContext()
	for iPlay in range(gc.getMAX_CIV_PLAYERS()):
		pPlay = gc.getPlayer(iPlay)
		if not pPlay.isAlive(): continue
		if pPlay.isBarbarian(): continue
		x, y = lSites[iPlay]
		pPlot = CyMap().plot(x, y)
		# Remove Goody Hut to fix crash?
		if pPlot.getImprovementType() == gc.getInfoTypeForString("IMPROVEMENT_GOODY_HUT"): pPlot.setImprovementType(-1)
		pPlay.setStartingPlot(pPlot, false)
		iCiv = pPlay.getCivilizationType()
		sName = gc.getCivilizationInfo(iCiv).getDescription()
		iBonus = pPlot.getBonusType(TeamTypes.NO_TEAM)
	# Only allow rock under mesa
	iRock = gc.getInfoTypeForString("TERRAIN_GRASS")
	for iPlotLoop in range(CyMap().numPlots()):
		pPlot = CyMap().plotByIndex(iPlotLoop)
		if pPlot.isPeak(): pPlot.setTerrainType(iRock, false, false)
